Prácticas de Programación 
PR1 - 20242 
 
Fecha límite de entrega: 05 / 04 / 2025 
 
Formato y fecha de entrega 
 
Se debe entregar la práctica antes del día 5 de abril de 2025 a las 23:59. 
Se deben entregar los archivos requeridos en la herramienta DSLab dentro del ejercicio PR1. Solo se valorará la última entrega dentro del plazo establecido.  
Concretamente, en esta actividad se requieren los siguientes archivos: 
●​Un archivo README.txt con el siguiente formato (ver ejemplo): 

 
 Formato: 
Correo electrónico UOC 
Apellidos, Nombre 
Sistema operativo utilizado 
 
Ejemplo: 
estudiante1@uoc.edu 
Apellido1 Apellido2, Nombre 
Windows 10 
 

●​Los archivos film.c, film.h, api.c y api.h. 

 
Finalmente, también se debe entregar un documento en formato PDF en el apartado de entregas de AC del aula de teoría que contenga un breve informe (máximo 2 páginas) sobre el código desarrollado. 
 
El incumplimiento del formato de entrega especificado anteriormente puede suponer un suspenso de la práctica. 
 
Objetivos 
 
●​Saber interpretar y seguir el código de otras personas. 
●​Saber compilar proyectos de código organizados en carpetas y bibliotecas. 
●​Saber implementar un proyecto de código a partir de su especificación. 

 
Criterios de corrección 
 
Cada ejercicio lleva asociada una puntuación sobre el total de la actividad. Se valorará tanto la corrección de las respuestas como su completitud. 
●​No seguir el formato de entrega, tanto en el tipo y nombre de los archivos como en el contenido requerido, implicará una penalización importante o la calificación con una D en la actividad. 
●​El código entregado debe compilar para ser evaluado. Si compila, se valorará: 
○​Que funcione tal como se describe en el enunciado. 
○​Que obtenga el resultado esperado dadas unas condiciones y datos de entrada específicos (pruebas proporcionadas). No es necesario pasar todas las pruebas, pero al menos debe mostrar el resultado en pantalla. 
○​Que se respeten los criterios de estilo y que el código esté comentado. Se valorará especialmente el uso de comentarios en inglés. 
○​Que las estructuras utilizadas sean las correctas. 
○​Que se separe adecuadamente la declaración e implementación de las acciones y funciones, utilizando los archivos correspondientes. 
○​El grado de optimización en tiempo y recursos utilizados en la solución entregada. 
○​Que se realice una gestión adecuada de la memoria, liberándola cuando sea necesario. 



 
Aviso 
 
Aprovechamos para recordar que está totalmente prohibido copiar en las PECs y prácticas de la asignatura. Se entiende que puede haber un trabajo o comunicación entre los estudiantes durante la realización de la actividad, pero la entrega de ésta debe ser individual y diferenciada del resto. Las entregas serán analizadas con herramientas de detección de plagio. 
El uso de herramientas de inteligencia artificial (IA) no está permitido en esta asignatura. Su utilización no es recomendable porque afecta el proceso de aprendizaje, ya que es necesario hacer los ejercicios para adquirir los conocimientos. 
Así pues, las entregas que contengan alguna parte idéntica respecto a entregas de otros estudiantes serán consideradas copias y todos los implicados (sin que sea relevante el vínculo existente entre ellos) suspenderán la actividad entregada. Es importante destacar que no se hará distinción entre coincidencias debidas a plagio entre estudiantes o al uso de la IA. 
Guía citación: https://biblioteca.uoc.edu/es/contenidos/Como-citar/index.html 
Monográfico sobre plagio: https://biblioteca.uoc.edu/es/biblioguias/biblioguia/Plagio-academico/ 
 
Observaciones 
En este documento se utilizan los siguientes símbolos para hacer referencia a los bloques de diseño y programación: 
 

Indica que el código mostrado es en lenguaje algorítmico. 

Indica que el código mostrado es en lenguaje C. 

Muestra la ejecución de un programa en lenguaje C. 
 
Análisis dinámico 
 
En esta actividad se utiliza memoria dinámica, lo que requiere que el programador reserve, inicialice y libere la memoria. Para ayudar a detectar memoria que no se ha liberado correctamente o errores en las operaciones con punteros relacionadas, existen herramientas que ejecutan un análisis dinámico del programa. Una herramienta de código abierto muy utilizada es Valgrind (https://valgrind.org/). El uso de esta herramienta queda fuera del alcance del curso. 
 
Para entender el significado de los códigos de error, podéis utilizar el siguiente enlace, donde encontraréis también algunos ejemplos de código que os ayudarán a entender cuándo se generan estos errores: 
 
https://bytes.usc.edu/cs104/wiki/valgrind/ 
 
 
DSLab 
 
En esta práctica, se introduce el uso de la herramienta DSLab (https://sd.uoc.edu/dslab/). Esta herramienta también se utiliza en otras asignaturas y tiene como objetivo: 
●​Proporcionar un entorno común donde evaluar los ejercicios de codificación. 

Os aconsejamos hacer envíos periódicos a la herramienta de los diferentes ejercicios de código, ya que os permitirá detectar posibles errores antes de la entrega final. Tened en cuenta que es la herramienta utilizada para corregir vuestros códigos, y que no se corregirá ningún código en otro entorno o máquina. Por lo tanto, si vuestro código no funciona en la herramienta DSLab, se considerará que no funciona, aunque lo haga en vuestro ordenador. 
Recordad que la entrega que se evaluará será la última que hagáis antes de que termine el plazo de entrega en la herramienta DSLab. En cualquier caso, también debéis entregar el informe del código desarrollado en el apartado correspondiente del aula, tal como indica el enunciado. 
La información básica que os será útil al utilizar DSLab: 
 
●​DSLab considera la entrega correcta únicamente si pasa todos los tests. 

 
●​Se muestra un resumen rápido del número de tests pasados. Por norma general, no será necesario pasarlos todos para aprobar la entrega. 

 
●​En los detalles se muestra: 
○​El detalle de los tests pasados y de los que han fallado. 
○​Es posible descargar un archivo con el texto que el programa muestra en pantalla (salida estándar). Se ha incluido el uso de valgrind en la salida estándar, de modo que en este apartado podréis ver el informe sobre la gestión de la memoria. Es recomendable revisarlo para asegurarse de que se hace un uso correcto de los punteros y de la memoria. 


●​También hay un log de ejecución que guarda la evolución de la ejecución del programa. Si, debido a una codificación incorrecta, el programa falla y no es capaz de mostrar el resultado de los tests, se debe revisar este log para determinar en qué punto se interrumpió la ejecución. 

 
Nota: si encontráis algún problema con la herramienta DSLab, informad a los profesores para que puedan corregir la incidencia lo antes posible. 
 
Enunciado 
En las PECs hemos estado trabajando de forma aislada partes del problema introducido en la PEC1. En las prácticas veremos cómo construir una aplicación más compleja que vaya incorporando de manera incremental lo trabajado en las PECs. 
Es habitual que las aplicaciones definan una API (Application Programming Interface) o interfaz de programación de aplicaciones. Básicamente, se trata de una abstracción de nuestra aplicación, en la que definimos los métodos y los datos, permitiendo que otras aplicaciones puedan interactuar con la nuestra sin necesidad de saber cómo se han implementado dichos métodos. 
Además, encapsularemos todas las funcionalidades en una biblioteca, que podrá ser utilizada por cualquier programa. En la siguiente figura se muestra la estructura de la práctica, en la cual tendremos una aplicación (ejecutable) que utilizará los métodos (acciones y funciones) de la API, implementada en una biblioteca. 
 

 
 
A nivel de código, lo que tendremos será un espacio de trabajo (Workspace) con dos proyectos: 
 
●​Aplicación: Será un proyecto igual al que utilizamos en las PECs, creado como un ejecutable simple. 
●​Biblioteca: Será un proyecto de tipo "Static library". En este caso, el resultado de la compilación y enlace no produce un ejecutable, sino un archivo .a o .lib, dependiendo del sistema operativo. Este archivo puede ser utilizado desde otra biblioteca o desde una aplicación. A diferencia de las aplicaciones, las bibliotecas no implementan el método main. 

 
Ejercicio 1: Preparación del entorno [0%]​ 
Junto con el enunciado se facilita un archivo de código con un espacio de trabajo (Workspace) que contiene dos proyectos. A continuación, se detallan las principales características de cada uno de ellos: 
●​UOCPlay: Este proyecto es la biblioteca en la que iremos añadiendo toda la funcionalidad de la práctica.  
○​El código está dividido en declaraciones (include) e implementaciones (src). 
○​Los archivos api.h y api.c contienen la declaración e implementación de la API, y por lo tanto, los métodos a los que se accederá desde la aplicación. 
○​Al compilar, debe buscar los archivos de cabecera en la carpeta include. 
○​La biblioteca debe generarse en la carpeta “lib” del Workspace. 
○​El nombre de la biblioteca añadirá una “d” cuando se compile en modo Debug. 



 
●​UOC20242: Este proyecto es nuestra aplicación. Se encarga de ejecutar las distintas pruebas para verificar el correcto funcionamiento de la biblioteca. 
○​El código principal está en la carpeta src, y el código de las pruebas en la carpeta test, separado en declaraciones (include) e implementaciones (src). 
○​Al compilar, debe buscar los archivos de cabecera (*.h) tanto en la carpeta de las pruebas (test/include) como en la carpeta correspondiente de la biblioteca (UOCPlay/include). 
○​Al vincular (link), es necesario indicar que busque las bibliotecas en el directorio lib del Workspace, incluyendo la biblioteca generada por el proyecto anterior. 
○​El ejecutable debe generarse en la carpeta “bin” del Workspace, que también será el directorio de trabajo cuando ejecutemos (working directory). 
○​El nombre del ejecutable añadirá una “d” cuando se compile en modo Debug. 



El objetivo de este ejercicio es tener el entorno proporcionado en funcionamiento. El Workspace está preparado para funcionar en la máquina virtual de la asignatura. Si no la utilizáis, puede ser necesario modificar las opciones de los proyectos para que funcione.​​Si se utiliza un entorno de programación diferente de CodeLite, se debe realizar el mismo ejercicio adaptándolo al entorno utilizado. Es muy importante organizar correctamente el código, y este es uno de los objetivos que se deben alcanzar al finalizar esta práctica. 
A continuación, se muestra una guía de las opciones (settings) de los proyectos donde se definen las características anteriores. Recordad que para acceder a las opciones del proyecto, podéis hacerlo con el menú contextual del proyecto (botón derecho) y la opción Settings. 

 
Localización de las opciones de configuración del proyecto UOC20242. 

 
Localización de las opciones de configuración del proyecto UOCPlay. 
 
1.​Permite cambiar entre la configuración de Debug y Release. 
2.​Define dónde se generan los archivos resultantes. 
3.​Define qué se ejecuta al usar el botón de play de CodeLite (
). Es necesario indicar el directorio de trabajo y el nombre de la aplicación, que será diferente en Debug y en Release. 

4.​Define en qué directorios se buscarán los archivos de cabecera. En la imagen se configura para un proyecto llamado “UOCTaxation”, debéis sustituirlo por “UOCPlay”. 
5.​Define en qué directorios se buscarán las bibliotecas y qué bibliotecas se deben añadir para generar la aplicación. 
6.​Define dónde se generan los archivos resultantes. 
7.​Define en qué directorios se buscarán los archivos de cabecera. 

 
Una vez seleccionadas todas las opciones correctas, al ejecutar deberíais ver el resultado de las pruebas. Inicialmente, todas, excepto la del ejercicio 1, aparecerán como fallidas. También os aparecerá que el nombre y correo electrónico no se han proporcionado (izquierda). Colocad los datos dentro del archivo README.txt del Workspace, tal como se indica en el apartado de entrega, y deberíais ver que se incorporan a la salida (derecha). 
 
Exemple de possible sortida del programa
 

Ejemplo de posible salida del programa. 
 
Ejercicio 2: Manipulación de TAD de TAD [20%] 
 
Material de consulta 
●​Apartados de la xWiki: TAD en memoria dinámica y TAD de TAD 

En este ejercicio se deben codificar las funciones que permiten la manipulación del catálogo de películas de la aplicación. Como podéis observar en el archivo film.h, la aplicación almacena el conjunto de películas dentro de una lista enlazada. Además, también almacena una lista enlazada con las referencias de las películas que están disponibles en el plan gratuito. Es decir, la primera de la listas (tFilmList) contiene todas las películas y, la segunda (tFreeFilmList), contiene una referencia a las películas gratuitas. 
Notar que en todo momento se habla de referencia en la segunda lista, por lo que se debe almacenar un puntero a una película ya existente en la primera lista. 
Asimismo, veréis que muchas de las funciones de este archivo devuelven el tipo de dato tApiError, una enumeración que podéis encontrar en el archivo error.h. A continuación, os mostramos una tabla de los tipos de errores que se espera que devuelvan estas funciones para este ejercicio: 
E_SUCCESS 
 Operación ejecutada correctamente. 
 
E_NOT_IMPLEMENTED 
 La funcionalidad aún no está implementada. 
 
E_FILM_DUPLICATED 
 Ya existe una película con ese nombre. 
 
E_FILM_NOT_FOUND 
 No existe ninguna película con ese nombre. 
 

Por lo tanto, en este ejercicio se solicita: 
 
a)​PR1_2a: Codifica la función catalog_init para que se pueda iniciar la estructura tCatalog recibida por parámetro. En caso de que se inicialice correctamente, esta función debe devolver E_SUCCESS. 
b)​PR1_2b: Codifica la función catalog_add para que añada una película dentro del catálogo de películas. Por lo tanto, se solicita que la película sea añadida en la lista de películas de la aplicación de tipo (tFilmList)  y, si esta es gratuita, también se añada una referencia a la lista de películas gratuitas de tipo (tFreeFilmList). En caso de que la película ya esté añadida, la función debe devolver E_FILM_DUPLICATED; si se añade correctamente, debe devolver E_SUCCESS. Controlad los errores debidamente en todo momento así como sus implicaciones (i.e. si la película no se ha podido añadir en la lista de películas, tampoco debe hacerlo en la lista de películas gratuitas a pesar de que lo sea). 
c)​PR1_2c: Codifica la función catalog_del para que se elimine una película del catálogo de películas. Esto implica que la película sea eliminada de la lista de películas de tipo (tFilmList) y, si es gratuita, que también sea eliminada de la lista de películas gratuitas (tFreeFilmList). En caso de que la película no exista en la lista de películas, la función debe devolver E_FILM_NOT_FOUND; en caso contrario, debe devolver E_SUCCESS. 
d)​PR1_2d: Codifica las funciones catalog_len y catalog_freeLen para que devuelvan la cantidad de películas totales y la cantidad de películas gratuitas respectivamente. 
e)​PR1_2e: Codifica la función catalog_free para que elimine toda la información del catálogo de películas. En caso de que lo elimine correctamente, esta función debe devolver E_SUCCESS. 

 
Ejercicio 3: Entrada de datos [40%] 
 
Material de consulta 
●​Apartados de la xWiki: Diseño descendente y TAD de TAD 

Hasta ahora hemos estado trabajando solo con los datos de personas (tPeople), sus suscripciones (tSubscriptions) y, más recientemente, con el catálogo de películas de la aplicación (tCatalog). Para facilitar la interacción con la API, queremos agrupar todos los datos con los que trabajamos en una única estructura de datos (tApiData). Esta estructura debe almacenar los siguientes datos: 
●​people: Conjunto de personas que son usuarias de la aplicación. Cada persona está identificada de manera única a partir de su documento de identidad. Los datos de una persona se almacenan en un tipo tPerson. El conjunto de personas se guarda en una tabla (tPeople).​ 
●​subscriptions: Conjunto de suscripciones dadas de alta en el sistema. Cada suscripción está identificada de manera única a partir de un identificador entero y se puede relacionar con una persona previamente dada de alta a partir de su documento de identidad. Los datos de cada suscripción se almacenan en una estructura de tipo tSubscription. El conjunto de suscripciones se guarda en una tabla (tSubscriptions). 

 
A partir de esta práctica, se almacena un TAD que contiene dos listas enlazadas con la información de las películas dadas de alta en la aplicación tal como se ha puesto en práctica en el ejercicio anterior: una que contiene todas las películas (tFilmList) y otra que contiene las referencias a las películas gratuitas (tFreeFilmList). Por lo tanto, la estructura de datos (tApiData) también debe almacenar los siguientes datos:​ 
●​catalog: Esta estructura almacena las películas de la aplicación. Cada película se identifica de manera única a partir de su nombre. Los datos de las películas se almacenan en un tipo tFilm. El conjunto de películas se guarda en una lista enlazada (tFilmList). Asimismo, las referencias a las películas gratuitas se almacenan en otra lista enlazada (tFreeFilmList). El conjunto de listas enlazadas mencionadas anteriormente se almacenan en un TAD de tipo tCatalog. 

 
Como parte del enunciado de la práctica se proporcionan los siguientes archivos: 
 
●​api.h/api.c con la declaración e implementación de los tipos de datos y métodos de la API. 
●​error.h con la declaración de los tipos de error que retornará la API (ya mencionado en el ejercicio anterior). 
●​csv.h/csv.c con la declaración e implementación de los tipos de datos y métodos relacionados con la gestión de datos en formato CSV. 
●​date.h/date.c con la declaración e implementación de los tipos de datos y métodos relacionados con la manipulación de fechas. 
●​person.h/person.c con la declaración e implementación de los tipos de datos y métodos relacionados con la gestión de personas. 
●​subscription.h/subscription.c con la declaración e implementación de los tipos de datos y métodos relacionados con las suscripciones. 
●​film.h/film.c con la declaración e implementación de los tipos de datos y métodos relacionados con las películas y el catálogo. 

 
Estos datos se consultarán y manipularán mediante los métodos de la API (definidos en el archivo api.h), los cuales generalmente retornarán un valor de tipo tApiError que indicará si se ha producido algún error o si la acción se ha ejecutado correctamente. Los códigos de error están definidos en el archivo error.h de la biblioteca. 
A continuación se detallan algunos de los posibles errores: 
 
E_SUCCESS 
 Operación ejecutada correctamente. 
 
E_NOT_IMPLEMENTED 
 La funcionalidad aún no está implementada. 
 
E_INVALID_ENTRY_TYPE 
 El tipo de dato es incorrecto. 
 
E_INVALID_ENTRY_FORMAT 
 El formato del dato no es correcto. 
 
E_FILM_DUPLICATED 
 Ya existe una película con ese nombre. 
 
E_FILM_NOT_FOUND 
 No existe ninguna película con ese nombre. 
 
E_PERSON_DUPLICATED 
 Ya existe una persona con ese documento. 
 
E_PERSON_NOT_FOUND 
 No existe ninguna persona con ese documento. 
 
E_SUBSCRIPTION_DUPLICATED 
 Ya existe una suscripción con ese identificador. 
 
E_SUBSCRIPTION_NOT_FOUND 
 No existe ninguna suscripción con ese identificador. 
 

 
En general, las funciones devuelven el valor inicial E_NOT_IMPLEMENTED. Una vez implementadas, devuelven el valor E_SUCCESS si todo ha funcionado correctamente. En caso contrario, devuelven un código de error asociado al tipo de error producido. 
 
Se solicita: 
 
a)​PR1_3a: Completa la definición del tipo de datos tApiData en el archivo api.h para que almacene todos los datos requeridos. 

 
b)​PR1_3b: Implementa la función api_initData en el archivo api.c, que inicializa una estructura de tipo tApiData dada. La función debe devolver E_SUCCESS.​ 
c)​PR1_3c: Implementa la función api_addPerson en el archivo api.c para que, dada una estructura de tipo tApiData y una persona en formato CSV tCSVEntry, añada esta persona a los datos de la aplicación. Si la persona ya existe, la función no añadirá nada y deberá devolver un error de tipo E_PERSON_DUPLICATE. 

 
Para cada dato, será necesario comprobar que el formato es correcto (asumimos que es correcto si el número de campos es el esperado, error asociado E_INVALID_ENTRY_FORMAT) y que el tipo es “PERSON” (puedes acceder al tipo mediante el método csv_getType, error asociado E_INVALID_ENTRY_TYPE). 
 
En caso de finalizar correctamente, la función debe devolver E_SUCCESS. 
 
Nota: En los archivos person.h y person.c encontrarás una nueva definición de person_parse que devuelve la información de una persona en una estructura de tipo tPerson. También encontrarás los métodos para gestionar la tabla de personas tPeople. Asimismo, tienes el método person_free para eliminar la memoria dinámica reservada temporalmente para guardar los datos de las personas.​ 
d)​PR1_3d: Implementa la función api_addSubscription en el archivo api.c para que, dada una estructura de tipo tApiData y una suscripción en formato CSV tCSVEntry, añada esta suscripción a los datos de la aplicación. Si la suscripción ya existe, la función debe devolver un error de tipo E_SUBSCRIPTION_DUPLICATED. Además, si no existe ninguna persona con el documento de identidad recibido dentro de la suscripción, la función debe devolver un error de tipo E_PERSON_NOT_FOUND. 

 
De manera análoga a la función anterior, se debe comprobar que el formato sea correcto y que el tipo también lo sea, siendo en este caso “SUBSCRIPTION”. En caso de que no lo sea por alguno de los dos motivos anteriores, la función debe devolver E_INVALID_ENTRY_FORMAT o E_INVALID_ENTRY_TYPE. 
 
En caso de finalizar correctamente, la función debe devolver E_SUCCESS. 
 
Nota: Es recomendable revisar las funciones que encontrarás en los archivos subscription.c y subscription.h. 
 
e)​PR1_3e: Implementa la función api_addFilm en el archivo api.c para que, dada una estructura de tipo tApiData y una película en formato CSV tCSVEntry, agregue esta película en los datos de la aplicación. Tened en cuenta que, si la película es gratuita, también se debe añadir una referencia a la lista enlazada de películas gratuitas. Por otro lado, si la película ya existe dentro del catálogo de la aplicación, esta función debe devolver un error de tipo E_FILM_DUPLICATED.​​De nuevo, para cada dato, será necesario comprobar que el formato sea correcto y que el tipo sea “FILM”. En caso de que no cumpla alguna de las dos condiciones, deberá retornar los errores E_INVALID_ENTRY_FORMAT o E_INVALID_ENTRY_TYPE. 

 
En caso de finalizar correctamente, la función debe devolver E_SUCCESS. 
 
Nota: Es recomendable revisar las funciones que encontrarás en los archivos film.c y film.h. 
 
f)​PR1_3f: Implementa los métodos api_peopleCount, api_subscriptionsCount, api_filmsCount y api_freeFilmsCount que, dada una estructura de datos de tipo tApiData, retornen la cantidad de personas, suscripciones, total de películas y la cantidad de películas gratuitas, respectivamente.​ 
g)​PR1_3g: Implementa la función api_freeData en el archivo api.c que elimina toda la información almacenada en una estructura de tipo tApiData dada. 

 
h)​PR1_3h: Implementa la función api_addDataEntry en el archivo api.c que, dada una estructura de tipo tApiData y un nuevo dato en formato CSV tCSVEntry, guarde este nuevo dato dentro de la estructura tApiData. Una entrada de datos puede ser de tipo “PERSON”, “SUBSCRIPTION” o “FILM”. Para cada dato, será necesario comprobar que el formato sea correcto (asumimos que es correcto si el número de campos es el esperado). Los posibles valores de retorno de esta función son los mencionados en los apartados anteriores. En cualquier caso, si la función finaliza sin ningún error, debe devolver E_SUCCESS. 

 
Importante: para realizar esta práctica, es necesario aplicar el diseño descendente. De esta manera, es posible simplificar la solución de los ejercicios y evitar repetir código, es decir, no será necesario implementar dos o más veces la misma funcionalidad. 
 
Ejercicio 4: Acceso a los datos [40%] 
 
Material de consulta 
●​Apartados de la xWiki: Diseño descendente y TAD de TAD 

 
Con el fin de no exponer los tipos de datos internos de la API, se ha decidido que todos los intercambios de datos a través de la API se realizarán utilizando CSV. Recordad que cada entrada en un archivo CSV corresponde a un dato (fila, objeto, …), y que, por lo tanto, el archivo es un conjunto de datos. Utilizaremos el tipo tCSVData para intercambiar múltiples datos (por ejemplo, listados) y el tipo tCSVEntry para objetos únicos.  
 
 
 
 
Se solicita: 
a)​PR1_4a: Implementa la función api_getSubscription en el archivo api.c que, dada una estructura de tipo tApiData y el identificador de una suscripción, guarde los datos de la suscripción en una estructura de tipo tCSVEntry. El formato de la suscripción que debe devolver es el siguiente: 

 
“id;document;start_date;end_date;plan;price;num_devices”​ 
Por ejemplo: 
 
“1;98765432J;01/01/2025;31/12/2025;Free;0;1” 
“2;33365111X;01/05/2025;30/04/2026;Standard;29.95;3” 
“3;12345672C;15/06/2025;14/06/2026;Standard;29.95;3” 
“4;55565432Z;21/03/2025;20/03/2026;Free;0;1” 
“5;47051307Z;01/01/2023;31/12/2028;Premium;29.95;3”​ 
El tipo de registro contendrá el valor “SUBSCRIPTION”. Si la suscripción no existe, la función debe devolver un error de tipo E_SUBSCRIPTION_NOT_FOUND; en caso contrario, E_SUCCESS. 
 
Nota: Es importante que el número de decimales para el campo price sea el mínimo posible tal como sucede en los ejemplos y que las fechas tengan el formato dd/mm/yyyy.​ 
b)​PR1_4b: Implementa la función api_getFilm en el archivo api.c que, dada una estructura de tipo tApiData y el nombre de una película, almacene la información de la película con dicho nombre en una estructura de tipo tCSVEntry.  

El formato de la película que debe devolver es el siguiente: 
“name;duration;genre;release;rating;is_free” 
​Por ejemplo: 
“Interstellar;02:49;4;07/11/2014;4.8;0​“Blade Runner 2049;02:44;4;06/10/2017;4.6;1”​“The Matrix;02:16;4;31/03/1999;4.9;1”​“Inception;02:28;0;16/07/2010;4.7;1”​“Mad Max: Fury Road;02:00;0;15/05/2015;4.5;0” 
El tipo de registro contendrá el valor “FILM”. Si la película no existe, la función debe devolver un error de tipo E_FILM_NOT_FOUND; en caso contrario, E_SUCCESS. 
 
Nota: Es importante que el número de decimales para el campo rating sea solo 1, que la duración tenga el formato hh:mm y la fecha dd/mm/yyyy. 
c)​PR1_4c: Implementa la función api_getFreeFilms en el archivo api.c que, dada una estructura de tipo tApiData, guarde los datos de todas las películas gratuitas registradas en una estructura de tipo tCSVData. Cada película se almacenará en una estructura de tipo tCSVEntry con el mismo formato que el apartado anterior: 

“name;duration;genre;release;rating;is_free” 
El tipo de registro contendrá el valor “FILM”. La función debe devolver E_SUCCESS.​ 
d)​PR1_4d: Implementa la función api_getFilmsByGenre en el archivo api.c que, dada una estructura de tipo tApiData y un género, guarde los datos de todas películas del género recibido en una estructura de tipo tCSVData. Cada película se almacenará en una estructura de tipo tCSVEntry con el mismo formato que los dos apartados anteriores: 

“name;duration;genre;release;rating;is_free” 
El tipo de registro contendrá el valor “FILM”. La función debe devolver E_SUCCESS. 
 
Nota: Podéis asumir que una cadena en formato CSV nunca superará los 2048 caracteres (2KB) de longitud. Los siguientes métodos pueden ser útiles para realizar este ejercicio: 
 
csv_init / csv_free 
 Inicializa / libera una estructura de tipo tCSVData 
 
csv_parseEntry 
 Llena una estructura de tipo tCSVEntry con la información contenida en una cadena en formato CSV 
 
csv_addStrEntry 
 Añade a una estructura de tipo tCSVData una nueva entrada (tCSVEntry) a partir de una cadena en formato CSV 
 
sprintf 
 Método similar a printf, pero que en lugar de mostrar la información formateada en pantalla, la guarda en una cadena 
 

 




UOC20242/
├── .vscode/
├── src/
│   └── main.c
├── test/
│   ├── include/
│   │   ├── test_data.h
│   │   ├── test_pr1.h
│   │   ├── test_suite.h
│   │   └── test.h
│   └── src/
│       ├── test_pr1.c
│       ├── test_suite.c
│       └── test.c
├── UOCPlay/
│   ├── include/
│   │   ├── api.h
│   │   ├── csv.h
│   │   ├── date.h
│   │   ├── error.h
│   │   ├── film.h
│   │   ├── person.h
│   │   └── subscription.h
│   └── src/
│       ├── api.c
│       ├── csv.c
│       ├── date.c
│       ├── film.c
│       ├── person.c
│       └── subscription.c
├── Makefile
└── README.md

UOCPlay.project/
├── Makefile
└── README.txt



/*********** api.c *****************/
#include <stdio.h>
#include <assert.h>
#include "csv.h"
#include "api.h"
#include <string.h>

// Get the API version information
const char* api_version()
{
    return "UOC PP 20242";
}

// Load data from a CSV file. If reset is true, remove previous data
tApiError api_loadData(tApiData* data, const char* filename, bool reset)
{
    tApiError error;
    FILE *fin;    
    char buffer[FILE_READ_BUFFER_SIZE];
    tCSVEntry entry;
    
    // Check input data
    assert( data != NULL );
    assert(filename != NULL);
    
    // Reset current data    
    if (reset) {
        // Remove previous information
        error = api_freeData(data);
        if (error != E_SUCCESS) {
            return error;
        }
        
        // Initialize the data
        error = api_initData(data);
        if (error != E_SUCCESS) {
            return error;
        }
    }

    // Open the input file
    fin = fopen(filename, "r");
    if (fin == NULL) {
        return E_FILE_NOT_FOUND;
    }
    
    // Read file line by line
    while (fgets(buffer, FILE_READ_BUFFER_SIZE, fin)) {
        // Remove new line character     
        buffer[strcspn(buffer, "\n\r")] = '\0';
        
        csv_initEntry(&entry);
        csv_parseEntry(&entry, buffer, NULL);
        // Add this new entry to the api Data
        error = api_addDataEntry(data, entry);
        if (error != E_SUCCESS) {
			csv_freeEntry(&entry);
			fclose(fin);
            return error;
        }
        csv_freeEntry(&entry);

    }
    
    fclose(fin);
    
    return E_SUCCESS;
}

// Initialize the data structure
tApiError api_initData(tApiData* data) {
	/////////////////////////////////
	// PR1_3b
	/////////////////////////////////
	
    /////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

// Add a person into the data if it does not exist
tApiError api_addPerson(tApiData* data, tCSVEntry entry) {
	/////////////////////////////////
	// PR1_3c
	/////////////////////////////////
	
	/////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

// Add a subscription if it does not exist
tApiError api_addSubscription(tApiData* data, tCSVEntry entry) {
	/////////////////////////////////
	// PR1_3d
	/////////////////////////////////
	
	/////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

// Add a film if it does not exist
tApiError api_addFilm(tApiData* data, tCSVEntry entry) {
	/////////////////////////////////
	// PR1_3e
	/////////////////////////////////
	
	/////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

// Get the number of people registered on the application
int api_peopleCount(tApiData data) {
	/////////////////////////////////
	// PR1_3f
	/////////////////////////////////
	
	/////////////////////////////////
    return -1;
}

// Get the number of subscriptions registered on the application
int api_subscriptionsCount(tApiData data) {
	/////////////////////////////////
	// PR1_3f
	/////////////////////////////////
	
	/////////////////////////////////
    return -1;
}

// Get the number of films registered on the application
int api_filmsCount(tApiData data) {
	/////////////////////////////////
	// PR1_3f
	/////////////////////////////////
	
	/////////////////////////////////
    return -1;
}

// Get the number of free films registered on the application
int api_freeFilmsCount(tApiData data) {
	/////////////////////////////////
	// PR1_3f
	/////////////////////////////////
	
	/////////////////////////////////
    return -1;
}

// Free all used memory
tApiError api_freeData(tApiData* data) {
	/////////////////////////////////
	// PR1_3g
	/////////////////////////////////
	
    /////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

// Add a new entry
tApiError api_addDataEntry(tApiData* data, tCSVEntry entry) {
	/////////////////////////////////
	// PR1_3h
	/////////////////////////////////
	
    /////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

// Get subscription data
tApiError api_getSubscription(tApiData data, int id, tCSVEntry *entry) {
	/////////////////////////////////
	// PR1_4a
	/////////////////////////////////
	
	/////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

// Get film data
tApiError api_getFilm(tApiData data, const char* name, tCSVEntry *entry) {
	/////////////////////////////////
	// PR1_4b
	/////////////////////////////////
	
	/////////////////////////////////
	return E_NOT_IMPLEMENTED;
}

// Get free films data
tApiError api_getFreeFilms(tApiData data, tCSVData *freeFilms) {
	/////////////////////////////////
	// PR1_4c
	/////////////////////////////////
	
	/////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

// Get films data by genre
tApiError api_getFilmsByGenre(tApiData data, tCSVData *films, int genre) {
	/////////////////////////////////
	// PR1_4d
	/////////////////////////////////
	
	/////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

/************ fin api.c *****************/

/*********** csv.c *****************/
#include "csv.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

// Initialize the tCSVData structure
void csv_init(tCSVData* data) {
    data->count = 0;
    data->isValid = false;
    data->entries = NULL;
}

// Initialize the tCSVEntry structure
void csv_initEntry(tCSVEntry* entry) {
    entry->numFields = 0;    
    entry->fields = NULL;
    entry->type = NULL;
}

// Add a new entry to the CSV Data
void csv_addStrEntry(tCSVData* data, const char* entry, const char* type) {
    assert( data != NULL );
    assert( entry != NULL );
    data->count++;
    if (data->count == 1) {
        data->entries = (tCSVEntry*) malloc(sizeof(tCSVEntry));
    } else {
        data->entries = (tCSVEntry*) realloc(data->entries, data->count * sizeof(tCSVEntry));
    }
    csv_initEntry(&(data->entries[data->count-1]));
    csv_parseEntry(&(data->entries[data->count-1]), entry, type);
}

// Parse the contents of a CSV file
void csv_parse(tCSVData* data, const char* input, const char* type) {
    const char *pStart, *pEnd;
    char *line;
    int len;
    
    assert(data->count == 0);
    assert(data->entries == NULL);
    assert(!data->isValid);
    
    pStart = input;
    pEnd = strchr(pStart, '\n');    
    while(pEnd != NULL && pEnd != pStart) {
        len = pEnd - pStart + 1;
        line = (char*) malloc(len * sizeof(char));
        memset(line, 0, len * sizeof(char));
        strncpy(line, pStart, pEnd - pStart);
        // Add the new entry line
        csv_addStrEntry(data, line, type);
        free(line);
        pStart = pEnd + 1;
        pEnd = strchr(pStart, '\n');
    }
    pEnd = strchr(pStart, '\0');
    if (pEnd != NULL && pEnd != pStart) {
        len = pEnd - pStart + 1;
        line = (char*) malloc(len * sizeof(char));
        memset(line, 0, len * sizeof(char));
        strncpy(line, pStart, pEnd - pStart);
        data->count++;
        if (data->count == 1) {
            data->entries = (tCSVEntry*) malloc(sizeof(tCSVEntry));
        } else {
            data->entries = (tCSVEntry*) realloc(data->entries, data->count * sizeof(tCSVEntry));
        }
        csv_initEntry(&(data->entries[data->count-1]));
        csv_parseEntry(&(data->entries[data->count-1]), line, type);
        free(line);
    }
    data->isValid = true;
}

// Print the content of the CSV data structure
void csv_print(tCSVData data) {
    int i;
    tCSVEntry* entry = NULL;
    
    for (i = 0; i < csv_numEntries(data); i++) {
        entry = csv_getEntry(data, i);
        printf("===============\n");
        printf("Entry %d: %s\n", i, entry->type);
        printf("===============\n");
        csv_printEntry(*entry);
        printf("===============\n");
    }    
}

// Print the content of the CSV entry structure
void csv_printEntry(tCSVEntry entry) {
    int i;
    char buffer[512];    
    printf("\tNum Fields: %d\n", csv_numFields(entry));
    for (i = 0; i < csv_numFields(entry); i++) {
        csv_getAsString(entry, i, buffer, 512);
        printf("\tField %d: %s\n", i, buffer);
    }
}

// Parse the contents of a CSV line
void csv_parseEntry(tCSVEntry* entry, const char* input, const char* type) {
    const char *pStart, *pEnd;    
    int len;
    bool readType = true;
    
    assert(entry->numFields == 0);
    assert(entry->fields == NULL);
    
    // If the type of the entry is not provided, use the first field
    if(type != NULL) {
        len = strlen(type) + 1;
        entry->type = (char*) malloc(len * sizeof(char));
        memset(entry->type, 0, len * sizeof(char));
        strncpy(entry->type, type, len);
        readType = false;
    }        
    pStart = input;
    pEnd = strchr(pStart, ';');    
    while(pEnd != NULL && pEnd != pStart) {        
        // Get the length of the field
        len = pEnd - pStart + 1;
        
        if(readType) {
            entry->type = (char*) malloc(len * sizeof(char));
            memset(entry->type, 0, len * sizeof(char));
            strncpy(entry->type, pStart, pEnd - pStart);
            readType = false;
        } else {
            entry->numFields++;
            if (entry->numFields == 1) {
                entry->fields = (char**) malloc(sizeof(char*));
            } else {
                entry->fields = (char**) realloc(entry->fields, entry->numFields * sizeof(char*));
            }                
            entry->fields[entry->numFields - 1] = (char*) malloc(len * sizeof(char));
            memset(entry->fields[entry->numFields - 1], 0, len * sizeof(char));
            strncpy(entry->fields[entry->numFields - 1], pStart, pEnd - pStart);
        }
        
        pStart = pEnd + 1;
        pEnd = strchr(pStart, ';');
    }
    pEnd = strchr(pStart, '\0');
    if (pEnd != NULL && pEnd != pStart) {
        
        assert(!readType);
        
        entry->numFields++;
        if (entry->numFields == 1) {
            entry->fields = (char**) malloc(sizeof(char*));
        } else {
            entry->fields = (char**) realloc(entry->fields, entry->numFields * sizeof(char*));
        }        
        len = pEnd - pStart + 1;
        entry->fields[entry->numFields - 1] = (char*) malloc(len * sizeof(char));
        memset(entry->fields[entry->numFields - 1], 0, len * sizeof(char));
        strncpy(entry->fields[entry->numFields - 1], pStart, pEnd - pStart);
    }
}

// Get the number of entries
bool csv_isValid(tCSVData data) {
    return data.isValid;
}

// Remove all data from structure
void csv_free(tCSVData* data) {
    int i;
    
    for (i = 0; i < data->count; i++) {
        csv_freeEntry(&(data->entries[i]));
    }
    free(data->entries);
    csv_init(data);
}

// Remove all data from structure
void csv_freeEntry(tCSVEntry* entry) {
    int i;
    
    if(entry->fields != NULL) {
        for(i = 0; i < entry->numFields; i++) {
            free(entry->fields[i]);
            entry->fields[i] = NULL;
        }
        
        free(entry->fields);
    }
    if(entry->type != NULL) {
        free(entry->type);
    }
    csv_initEntry(entry);
}

// Get the number of entries
int csv_numEntries(tCSVData data) {
    return data.count;
}

// Get the type of information contained in the entry
const char* csv_getType(tCSVEntry* entry) {
    return (const char*)entry->type;
}

// Get an entry from the CSV data
tCSVEntry* csv_getEntry(tCSVData data, int position) {
    return &(data.entries[position]);
}

// Get the number of fields for a given entry
int csv_numFields(tCSVEntry entry) {
    return entry.numFields;
}

// Get a field from the given entry as integer
int csv_getAsInteger(tCSVEntry entry, int position) {
    return atoi(entry.fields[position]);
}

// Get a field from the given entry as string
void csv_getAsString(tCSVEntry entry, int position, char* buffer, int length) {
    memset(buffer, 0, length);
    strncpy(buffer, entry.fields[position], length - 1);
}

// Get a field from the given entry as integer
float csv_getAsReal(tCSVEntry entry, int position) {
    return atof(entry.fields[position]);
}

// Compare if two entries are the same
bool csv_equalsEntry(tCSVEntry entry1, tCSVEntry entry2) {
    int i;
    if (entry1.numFields != entry2.numFields) {
        return false;
    }
    if (strcmp(entry1.type, entry2.type) != 0) {
        return false;
    }
    for (i = 0; i < entry1.numFields ; i++) {
        if (strcmp(entry1.fields[i], entry2.fields[i]) != 0) {
            return false;
        }
    }
    
    return true;
}

// Compare if two data objects are the same
bool csv_equals(tCSVData data1, tCSVData data2) {
    int i;
    if (data1.count != data2.count) {
        return false;
    }
    for (i = 0; i < data1.count ; i++) {
        if (!csv_equalsEntry(data1.entries[i], data2.entries[i])) {
            return false;
        }
    }
    
    return true;
}

/************ fin csv.c *****************/

/*********** date.c *****************/
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include "date.h"

// Copy a time from src to dst
void time_cpy(tTime *dst, tTime src)
{
	// Check output daa
	assert(dst != NULL);
	
	dst->hour = src.hour;
	dst->minutes = src.minutes;
}

// Parse a tDate from string information
void date_parse(tDate* date, const char* text)
{
    // Check output data
    assert(date != NULL);
    
    // Check input date
    assert(text != NULL);
    assert(strlen(text) == DATE_LENGTH);
 
    // Parse the input date
    sscanf(text, "%d/%d/%d", &(date->day), &(date->month), &(date->year));
}

// Copy a date from src to dst
void date_cpy(tDate *dst, tDate src) {
    // Check output data
    assert(dst != NULL);
    
    dst->day = src.day;
    dst->month = src.month;
    dst->year = src.year;
}

// Compare two dates
int date_cmp(tDate date1, tDate date2) {
    // Checkl year
    if (date1.year < date2.year) {
        return -1;
    }
    if (date1.year > date2.year) {
        return 1;
    }
    // Check month
    if (date1.month < date2.month) {
        return -1;
    }
    if (date1.month > date2.month) {
        return 1;
    }  
    // Check day
    if (date1.day < date2.day) {
        return -1;
    }
    if (date1.day > date2.day) {
        return 1;
    }
    
    return 0;
}

// Parse a tDateTime from string information
void dateTime_parse(tDateTime* dateTime, const char* date, const char* time) {
    // Check output data
    assert(dateTime != NULL);
    
    // Check input date
    assert(date != NULL);
    assert(strlen(date) == 10);
    
    // Check input time
    assert(time != NULL);
    assert(strlen(time) == 5);
    
    // Parse the input date
    sscanf(date, "%d/%d/%d", &(dateTime->date.day), &(dateTime->date.month), &(dateTime->date.year));
    
    // Parse the input time
    sscanf(time, "%d:%d", &(dateTime->time.hour), &(dateTime->time.minutes));
}

// Compare two tDateTime structures and return -1 if dateTime1<dateTime2, 0 if equals and 1 if dateTime1>dateTime2.
int dateTime_cmp(tDateTime dateTime1, tDateTime dateTime2) {    
    // Checkl year
    if (dateTime1.date.year < dateTime2.date.year) {
        return -1;
    }
    if (dateTime1.date.year > dateTime2.date.year) {
        return 1;
    }
    // Check month
    if (dateTime1.date.month < dateTime2.date.month) {
        return -1;
    }
    if (dateTime1.date.month > dateTime2.date.month) {
        return 1;
    }  
    // Check day
    if (dateTime1.date.day < dateTime2.date.day) {
        return -1;
    }
    if (dateTime1.date.day > dateTime2.date.day) {
        return 1;
    }
    // Check hour
    if (dateTime1.time.hour < dateTime2.time.hour) {
        return -1;
    }
    if (dateTime1.time.hour > dateTime2.time.hour) {
        return 1;
    }
    // Check minutes
    if (dateTime1.time.minutes < dateTime2.time.minutes) {
        return -1;
    }
    if (dateTime1.time.minutes > dateTime2.time.minutes) {
        return 1;
    }
    
    return 0;
}

// Compare two tDateTime structures and return true if they contain the same value or false otherwise.
bool dateTime_equals(tDateTime dateTime1, tDateTime dateTime2) {
    return dateTime_cmp(dateTime1, dateTime2) == 0;
}

/************ fin date.c *****************/

/*********** film.c *****************/
#include "film.h"
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

// Parse input from CSVEntry
void film_parse(tFilm* data, tCSVEntry entry) {
	// Check input data
	assert(data != NULL);
	assert(csv_numFields(entry) == NUM_FIELDS_FILM);

	int pos = 0;

	// Name
	const char* name = entry.fields[pos++];
	assert(name != NULL);

	// Duration
	assert(strlen(entry.fields[pos]) == TIME_LENGTH);
	tTime duration;
	int itemsRead = sscanf(entry.fields[pos++], "%d:%d", &duration.hour, &duration.minutes);
	assert(itemsRead == 2);

	// Genre
	int genreValue = csv_getAsInteger(entry, pos++);
	assert(genreValue >= GENRE_FIRST && genreValue < GENRE_END);
	tFilmGenre genre = (tFilmGenre)genreValue;

	// Release date
	assert(strlen(entry.fields[pos]) == DATE_LENGTH);
	tDate release;
	itemsRead = sscanf(entry.fields[pos++], "%d/%d/%d", &release.day, &release.month, &release.year);
	assert(itemsRead == 3);

	// Rating
	float rating = csv_getAsReal(entry, pos++);
	assert(rating >= RATING_MIN && rating <= RATING_MAX);

	// isFree
	int isFree = csv_getAsInteger(entry, pos++);
	assert(isFree == 0 || isFree == 1);

	// Call film_init with the parsed data
	film_init(data, name, duration, genre, release, rating, (bool)isFree);
}

// Initialize a film
void film_init(tFilm* data, const char* name, tTime duration, tFilmGenre genre, tDate release, float rating, bool isFree) {
	// Check preconditions
	assert(data != NULL);
	assert(name != NULL);
	
	// Name
	data->name = (char*) malloc((strlen(name) + 1) * sizeof(char));
	assert(data->name != NULL);
	strcpy(data->name, name);
	
	// Duration
	time_cpy(&data->duration, duration);
	
	// Genre
	data->genre = genre;
	
	// Release
	date_cpy(&data->release, release);
	
	// Rating
	data->rating = rating;
	
	// isFree
	data->isFree = isFree;
}

// Copy a film from src to dst
void film_cpy(tFilm* dst, tFilm src) {
	// Check preconditions
	assert(dst != NULL);
	
	film_init(dst, src.name, src.duration, src.genre, src.release, src.rating, src.isFree);
}

// Get film data using a string
void film_get(tFilm data, char* buffer) {
	// Print all data at same time
    sprintf(buffer,"%s;%02d:%02d;%d;%02d/%02d/%04d;%.1f;%d",
        data.name,
		data.duration.hour, data.duration.minutes,
		data.genre,
		data.release.day, data.release.month, data.release.year,
		data.rating,
		data.isFree);
}

// Remove the data from a film
void film_free(tFilm* data) {
	// Check preconditions
	assert(data != NULL);
	
	if (data->name != NULL)
	{
		free(data->name);
		data->name = NULL;
	}
}

// Initialize the films list
tApiError filmList_init(tFilmList* list) {
	// Check preconditions
	assert(list != NULL);
	
	list->first = NULL;
	list->last = NULL;
	list->count = 0;
	
	return E_SUCCESS;
}

// Add a new film to the list
tApiError filmList_add(tFilmList* list, tFilm film) {
	// Check preconditions
	assert(list != NULL);
	
	tFilmListNode *node;
	
	// Check if the film is already in the list
	if (filmList_find(*list, film.name) != NULL)
		return E_FILM_DUPLICATED;
	
	// Create the node
	node = (tFilmListNode*)malloc(sizeof(tFilmListNode));
	assert(node != NULL);
	
	// Assign the properties of the nodes
	film_cpy(&node->elem, film);
	node->next = NULL;
	
	// Link the new node to the end of the list
	if (list->first == NULL)
		list->first = node;
	else
		list->last->next = node;
	
	list->last = node;
	list->count++;
	
	return E_SUCCESS;
}

// Remove a film from the list
tApiError filmList_del(tFilmList* list, const char* name) {
	// Check preconditions
	assert(list != NULL);
	assert(name != NULL);
	
	tFilmListNode *node, *prev;
	
	// Iterate until the node and remove it
	node = list->first;
	prev = NULL;
	
	while (node != NULL)
	{
		if (strcmp(node->elem.name, name) == 0)
			break;
		
		prev = node;
		node = node->next;
	}
	
	// If node does not exist, return an error
	if (node == NULL)
		return E_FILM_NOT_FOUND;
	
	// Link the list without the node to remove
	if (prev == NULL)
		list->first = node->next;
	else
		prev->next = node->next;
	
	if (list->last == node)
		list->last = prev;
	
	list->count--;
	
	film_free(&(node->elem));
	free(node);
	
	return E_SUCCESS;
}

// Return a pointer to the film
tFilm* filmList_find(tFilmList list, const char* name) {
	// Check preconditions
	assert(name != NULL);
	
	tFilmListNode *node;
	node = list.first;
	
	while (node != NULL)
	{
		if (strcmp(node->elem.name, name) == 0)
			return &(node->elem);
		
		node = node->next;
	}
	
	return NULL;
}

// Remove the films from the list
tApiError filmList_free(tFilmList* list) {
	// Check preconditions
	assert(list != NULL);
	
	tFilmListNode *node, *auxNode;
	
	node = list->first;
	auxNode = NULL;
	
	while (node != NULL)
	{
		auxNode = node->next;
		
		film_free(&(node->elem));
		free(node);
		
		node = auxNode;
	}
	
	filmList_init(list);
	
	return E_SUCCESS;
}

// Initialize the free films list
tApiError freeFilmList_init(tFreeFilmList* list) {
	// Check preconditions
	assert(list != NULL);
	
	list->first = NULL;
	list->last = NULL;
	list->count = 0;
	
	return E_SUCCESS;
}

// Add a new free film to the list
tApiError freeFilmList_add(tFreeFilmList* list, tFilm* film) {
	// Check preconditions
	assert(list != NULL);
	assert(film != NULL);

	if (freeFilmList_find(*list, film->name) != NULL)
		return E_FILM_DUPLICATED;

	tFreeFilmListNode* node = (tFreeFilmListNode*)malloc(sizeof(tFreeFilmListNode));
	assert(node != NULL);

	node->elem = film; // Store the reference
	node->next = NULL;

	if (list->first == NULL)
		list->first = node;
	else
		list->last->next = node;

	list->last = node;
	list->count++;

	return E_SUCCESS;
}

// Remove a free film from the list
tApiError freeFilmList_del(tFreeFilmList* list, const char* name) {
	// Check preconditions
	assert(list != NULL);
	assert(name != NULL);

	tFreeFilmListNode *node = list->first, *prev = NULL;

	while (node != NULL)
	{
		if (strcmp(node->elem->name, name) == 0)
			break;
		prev = node;
		node = node->next;
	}

	if (node == NULL)
		return E_FILM_NOT_FOUND;

	if (prev == NULL)
		list->first = node->next;
	else
		prev->next = node->next;

	if (list->last == node)
		list->last = prev;

	free(node);
	list->count--;

	return E_SUCCESS;
}

// Return a pointer to the free film
tFilm* freeFilmList_find(tFreeFilmList list, const char* name) {
	// Check preconditions
	assert(name != NULL);
	
	tFreeFilmListNode *node;
	node = list.first;
	
	while (node != NULL)
	{
		if (strcmp(node->elem->name, name) == 0)
			return node->elem;
			
		node = node->next;
	}
	
	return NULL;
}

// Remove the free films from the list
tApiError freeFilmsList_free(tFreeFilmList* list) {
	// Check preconditions
	assert(list != NULL);
	
	tFreeFilmListNode *node, *auxNode;
	
	node = list->first;
	auxNode = NULL;
	
	while (node != NULL)
	{
		auxNode = node->next;
		free(node);
		node = auxNode;
	}
	
	freeFilmList_init(list);
	
	return E_SUCCESS;
}

// Initialize the films catalog
tApiError catalog_init(tCatalog* catalog) {
	/////////////////////////////////
	// PR1_2a
	/////////////////////////////////
	assert(catalog != NULL);

	assert(catalog.filmList.count == 0);
assert(catalog.filmList.first == NULL);
assert(catalog.filmList.last == NULL);

assert(catalog.freeFilmList.count == 0);
assert(catalog.freeFilmList.first == NULL);
assert(catalog.freeFilmList.last == NULL);

    printf("Initializing film list...\n");
    tApiError error = filmList_init(&catalog->filmList);
    if (error != E_SUCCESS) {
        printf("Error initializing film list: %d\n", error);
        return error;
    }

    printf("Initializing free film list...\n");
    error = freeFilmList_init(&catalog->freeFilmList);
    if (error != E_SUCCESS) {
        printf("Error initializing free film list: %d\n", error);
        return error;
    }

    printf("Catalog initialized successfully.\n");
    return E_SUCCESS;
}

// Add a new film to the catalog
tApiError catalog_add(tCatalog* catalog, tFilm film) {
	/////////////////////////////////
	// PR1_2b
	/////////////////////////////////
	
	/////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

// Remove a film from the catalog
tApiError catalog_del(tCatalog* catalog, const char* name) {
	/////////////////////////////////
	// PR1_2c
	/////////////////////////////////
	
	/////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

// Return the number of total films
int catalog_len(tCatalog catalog) {
	/////////////////////////////////
	// PR1_2d
	/////////////////////////////////
	
	/////////////////////////////////
    return -1;
}

// Return the number of free films
int catalog_freeLen(tCatalog catalog) {
	/////////////////////////////////
	// PR1_2d
	/////////////////////////////////
	
	/////////////////////////////////
    return -1;
}

// Remove the films from the catalog
tApiError catalog_free(tCatalog* catalog) {
	/////////////////////////////////
	// PR1_2e
	/////////////////////////////////
	
	/////////////////////////////////
    return E_NOT_IMPLEMENTED;
}

/************ fin film.c *****************/

/*********** person.c *****************/
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include "person.h"

// Parse input from CSVEntry
void person_parse(tPerson* data, tCSVEntry entry) {
    // Check input data
    assert(data != NULL);
    
    // Check entry fields
    assert(csv_numFields(entry) == NUM_FIELDS_PERSON);
      
    // Copy identity document data
    data->document = (char*) malloc((strlen(entry.fields[0]) + 1) * sizeof(char));
    assert(data->document != NULL);
    memset(data->document, 0, (strlen(entry.fields[0]) + 1) * sizeof(char));
    csv_getAsString(entry, 0, data->document, strlen(entry.fields[0]) + 1);
    
    // Copy name data
    data->name = (char*) malloc((strlen(entry.fields[1]) + 1) * sizeof(char));
    assert(data->name != NULL);
    memset(data->name, 0, (strlen(entry.fields[1]) + 1) * sizeof(char));
    csv_getAsString(entry, 1, data->name, strlen(entry.fields[1]) + 1);
    
    // Copy surname data
    data->surname = (char*) malloc((strlen(entry.fields[2]) + 1) * sizeof(char));
    assert(data->surname != NULL);
    memset(data->surname, 0, (strlen(entry.fields[2]) + 1) * sizeof(char));
    csv_getAsString(entry, 2, data->surname, strlen(entry.fields[2]) + 1);
    
    // Copy phone data
    data->phone = (char*) malloc((strlen(entry.fields[3]) + 1) * sizeof(char));
    assert(data->phone != NULL);
    memset(data->phone, 0, (strlen(entry.fields[3]) + 1) * sizeof(char));
    csv_getAsString(entry, 3, data->phone, strlen(entry.fields[3]) + 1);

    // Copy email data
    data->email = (char*) malloc((strlen(entry.fields[4]) + 1) * sizeof(char));
    assert(data->email != NULL);
    memset(data->email, 0, (strlen(entry.fields[4]) + 1) * sizeof(char));
    csv_getAsString(entry, 4, data->email, strlen(entry.fields[4]) + 1);
    
    // Copy address data
    data->address = (char*) malloc((strlen(entry.fields[5]) + 1) * sizeof(char));
    assert(data->address != NULL);
    memset(data->address, 0, (strlen(entry.fields[5]) + 1) * sizeof(char));
    csv_getAsString(entry, 5, data->address, strlen(entry.fields[5]) + 1);
    
    // Copy cp data
    data->cp = (char*) malloc((strlen(entry.fields[6]) + 1) * sizeof(char));
    assert(data->cp != NULL);
    memset(data->cp, 0, (strlen(entry.fields[6]) + 1) * sizeof(char));
    csv_getAsString(entry, 6, data->cp, strlen(entry.fields[6]) + 1);
    
    // Check birthday lenght
    assert(strlen(entry.fields[7]) == 10);
    // Parse the birthday date
    sscanf(entry.fields[7], "%d/%d/%d", &(data->birthday.day), &(data->birthday.month), &(data->birthday.year));
}

// Copy the data from the source to destination
void person_cpy(tPerson* destination, tPerson source) {
    // Copy identity document data
    destination->document = (char*) malloc((strlen(source.document) + 1) * sizeof(char));
    assert(destination->document != NULL);
    strcpy(destination->document, source.document);
    
    // Copy name data
    destination->name = (char*) malloc((strlen(source.name) + 1) * sizeof(char));
    assert(destination->name != NULL);
    strcpy(destination->name, source.name);
    
    // Copy surname data
    destination->surname = (char*) malloc((strlen(source.surname) + 1) * sizeof(char));
    assert(destination->surname != NULL);
    strcpy(destination->surname, source.surname);
    
    // Copy phone data
    destination->phone = (char*) malloc((strlen(source.phone) + 1) * sizeof(char));
    assert(destination->phone != NULL);
    strcpy(destination->phone, source.phone);

    // Copy email data
    destination->email = (char*) malloc((strlen(source.email) + 1) * sizeof(char));
    assert(destination->email != NULL);
    strcpy(destination->email, source.email);
    
    // Copy address data
    destination->address = (char*) malloc((strlen(source.address) + 1) * sizeof(char));
    assert(destination->address != NULL);
    strcpy(destination->address, source.address);
    
    // Copy cp data
    destination->cp = (char*) malloc((strlen(source.cp) + 1) * sizeof(char));
    assert(destination->cp != NULL);
    strcpy(destination->cp, source.cp);
    
    // Copy the birthday date
    destination->birthday = source.birthday;
}

// Remove the data from a person
void person_free(tPerson* data) {
    // Check input data
    assert(data != NULL);
    
    // Release document data
    if(data->document != NULL) free(data->document);
    data->document = NULL;
    
    // Release name data
    if(data->name != NULL) free(data->name);
    data->name = NULL;
    
    // Release surname data
    if(data->surname != NULL) free(data->surname);
    data->surname = NULL;
    
    // Release phone data
    if(data->phone != NULL) free(data->phone);
    data->phone = NULL;
    
    // Release email data
    if(data->email != NULL) free(data->email);
    data->email = NULL;
    
    // Release address data
    if(data->address != NULL) free(data->address);
    data->address = NULL;
    
    // Release cp data
    if(data->cp != NULL) free(data->cp);
    data->cp = NULL;
}

// Initialize the people data
tApiError people_init(tPeople* data) {
    // Check input/output data
    assert(data != NULL);
    
    data->elems = NULL;
    data->count = 0;
	
	return E_SUCCESS;
}

// Return the number of people
int people_count(tPeople data) {
	return data.count;
}

// Add a new person
tApiError people_add(tPeople* data, tPerson person) {
    // Check input data
    assert(data != NULL);
    
	// If person already exist, return an error
	if (people_find(data[0], person.document) >= 0)
		return E_PERSON_DUPLICATED;
	
    // Allocate memory for new element
	if (data->count == 0) {
		// Request new memory space
		data->elems = (tPerson*) malloc(sizeof(tPerson));            
	} else {
		// Modify currently allocated memory
		data->elems = (tPerson*) realloc(data->elems, (data->count + 1) * sizeof(tPerson));            
	}
	assert(data->elems != NULL);
			
	// Copy the data to the new position
	person_cpy(&(data->elems[data->count]), person);
	
	// Increase the number of elements
	data->count ++;
	
	return E_SUCCESS;
}

// Remove a person
tApiError people_del(tPeople* data, const char *document) {
    int i;
    int pos;
    
    // Check input data
    assert(data != NULL);
    
    // Find if it exists
    pos = people_find(data[0], document);
    
	// If person does not exist, return an error
	if (pos < 0)
		return E_PERSON_NOT_FOUND;
	
	// Remove current position memory
	person_free(&(data->elems[pos]));
	// Shift elements 
	for(i = pos; i < data->count-1; i++) {
		// Copy address of element on position i+1 to position i
		data->elems[i] = data->elems[i+1];
	}
	// Update the number of elements
	data->count--;
	// Resize the used memory
	if (data->count == 0) {
		// No element remaining
		free(data->elems);
		data->elems = NULL;
	} else {
		// Still some elements are remaining
		data->elems = (tPerson*)realloc(data->elems, data->count * sizeof(tPerson));
	}
	
	return E_SUCCESS;
}

// Return the position of a person with provided document. -1 if it does not exist
int people_find(tPeople data, const char* document) {
    int i;
    
    for(i = 0; i < data.count; i++) {
        if(strcmp(data.elems[i].document, document) == 0 ) {
            return i;
        }
    }
    
    return -1;
}

// Print the person data
void people_print(tPeople data) {
    int i;
    
    for(i = 0; i < data.count; i++) {
        // Print position and document
        printf("%d;%s;", i, data.elems[i].document);
        // Print name and surname
        printf("%s;%s;", data.elems[i].name, data.elems[i].surname);        
        // Print phone
        printf("%s;", data.elems[i].phone);
        // Print email
        printf("%s;", data.elems[i].email);
        // Print address and CP
        printf("%s;%s;", data.elems[i].address, data.elems[i].cp);
        // Print birthday date
        printf("%02d/%02d/%04d\n", data.elems[i].birthday.day, data.elems[i].birthday.month, data.elems[i].birthday.year);
    }
}

// Remove the data from all persons
tApiError people_free(tPeople* data) {
    int i;
    
    // Check input data
    assert(data != NULL);
    
    // Remove contents
    for(i = 0; i < data->count; i++) {
        person_free(&(data->elems[i]));
    }    
    
    // Release memory
    if (data->count > 0) {
        free(data->elems);
        data->elems = NULL;
        data->count = 0;
    }
	
	return E_SUCCESS;
}
/************ fin person.c *****************/

/*********** subscription.c *****************/
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include "subscription.h"

// Parse input from CSVEntry
void subscription_parse(tSubscription* data, tCSVEntry entry) {
    // Check input data
    assert(data != NULL);

    // Check entry fields
    assert(csv_numFields(entry) == NUM_FIELDS_SUBSCRIPTION);

    int pos = 0; // Allow to easy incremental position of the income data

    // Copy subscription's id data
    data->id = csv_getAsInteger(entry, pos);

    // Copy identity document data
    assert(strlen(entry.fields[++pos]) == MAX_DOCUMENT);
    csv_getAsString(entry, pos, data->document, MAX_DOCUMENT + 1);

    // Parse start date
    assert(strlen(entry.fields[++pos]) == DATE_LENGTH);
    date_parse(&(data->start_date), entry.fields[pos]);

    // Parse end date
    assert(strlen(entry.fields[++pos]) == DATE_LENGTH);
    date_parse(&(data->end_date), entry.fields[pos]);

    // Copy plan data
    csv_getAsString(entry, ++pos, data->plan, MAX_PLAN + 1);

    // Copy price data
    data->price = csv_getAsReal(entry, ++pos);

    // Copy number of devices data
    data->numDevices = csv_getAsInteger(entry, ++pos);

    // Check preconditions that needs the readed values
    assert(data->price >= 0);
    assert(data->numDevices >= 1);
}

// Copy the data from the source to destination (individual data)
void subscription_cpy(tSubscription* destination, tSubscription source) {
    // Copy subscription's id data
    destination->id = source.id;

    // Copy identity document data
    strncpy(destination->document, source.document, MAX_DOCUMENT + 1);

    // Copy start date
    date_cpy(&(destination->start_date), source.start_date);

    // Copy end date
    date_cpy(&(destination->end_date), source.end_date);

    // Copy plan data
    strncpy(destination->plan, source.plan, MAX_PLAN + 1);

    // Copy price data
    destination->price = source.price;

    // Copy number of devices data
    destination->numDevices = source.numDevices;
}

// Get subscription data using a string
void subscription_get(tSubscription data, char* buffer) {
    // Print all data at same time
    sprintf(buffer,"%d;%s;%02d/%02d/%04d;%02d/%02d/%04d;%s;%g;%d",
        data.id,
        data.document,
        data.start_date.day, data.start_date.month, data.start_date.year,
        data.end_date.day, data.end_date.month, data.end_date.year,
        data.plan,
        data.price,
        data.numDevices);
}

// Initialize subscriptions data
tApiError subscriptions_init(tSubscriptions* data) {
    // Check input data
    assert(data != NULL);
    data->elems = NULL;
    data->count = 0;
	
	return E_SUCCESS;
}

// Return the number of subscriptions
int subscriptions_len(tSubscriptions data) {
	return data.count;
}

// Add a new subscription
tApiError subscriptions_add(tSubscriptions* data, tPeople people, tSubscription subscription) {
    // Check input data
    assert(data != NULL);

	// If subscription already exists, return an error
	if (subscriptions_find(*data, subscription.id) >= 0)
		return E_SUBSCRIPTION_DUPLICATED;

	// If the person does not exist, return an error
	if (people_find(people, subscription.document) < 0)
		return E_PERSON_NOT_FOUND;

    // Copy the data to the new position
	if (data->elems == NULL) {
		data->elems = (tSubscription*) malloc(sizeof(tSubscription));
	} else {
		data->elems = (tSubscription*) realloc(data->elems, (data->count + 1) * sizeof(tSubscription));
	}
	assert(data->elems != NULL);
	subscription_cpy(&(data->elems[data->count]), subscription);

	// Increase the number of elements
	data->count++;
	
	return E_SUCCESS;
}

// Remove a subscription
tApiError subscriptions_del(tSubscriptions* data, int id) {
    int idx;
    int i;
    
    // Check if an entry with this data already exists
    idx = subscriptions_find(*data, id);
	
	// If the subscription does not exist, return an error
	if (idx < 0)
		return E_SUBSCRIPTION_NOT_FOUND;
    
    // Shift elements to remove selected
	for(i = idx; i < data->count-1; i++) {
			// Copy element on position i+1 to position i
			subscription_cpy(&(data->elems[i]), data->elems[i+1]);
	}
	// Update the number of elements
	data->count--;  
	/////////////////////////////////
	if (data->count > 0) {
		data->elems = (tSubscription*) realloc(data->elems, data->count * sizeof(tSubscription));
		assert(data->elems != NULL);
	} else {
		subscriptions_free(data);
	}
	
	return E_SUCCESS;
}

// Get subscription data of position index using a string
void subscriptions_get(tSubscriptions data, int index, char* buffer)
{
    assert(index >= 0 && index < data.count);
    subscription_get(data.elems[index], buffer);
}

// Returns the position of a subscription looking for id's subscription. -1 if it does not exist
int subscriptions_find(tSubscriptions data, int id) {
    int i = 0;
    while (i < data.count) {
        if (data.elems[i].id == id) {
            return i;
        }
        i++;
    }

    return -1;
}

// Print subscriptions data
void subscriptions_print(tSubscriptions data) {
    char buffer[1024];
    int i;
    for (i = 0; i < data.count; i++) {
        subscriptions_get(data, i, buffer);
        printf("%s\n", buffer);
    }
}

// Remove all elements 
tApiError subscriptions_free(tSubscriptions* data) { 
    /////////////////////////////////
    if (data->elems != NULL) {
        free(data->elems);
    }
    subscriptions_init(data);
	
	return E_SUCCESS;
    /////////////////////////////////    
}
/************ fin subscription.c *****************/

/*********** api.h *****************/
#ifndef __UOCPLAY_API__H
#define __UOCPLAY_API__H
#include <stdbool.h>
#include "error.h"
#include "csv.h"
#include "person.h"
#include "subscription.h"
#include "film.h"

#define FILE_READ_BUFFER_SIZE 2048

// Type that stores all the application data
typedef struct _ApiData {
    /////////////////////////////////
	// PR1_3a
	/////////////////////////////////
    
    /////////////////////////////////
} tApiData;

// Get the API version information
const char* api_version();

// Load data from a CSV file. If reset is true, remove previous data
tApiError api_loadData(tApiData* data, const char* filename, bool reset);

// Initialize the data structure
tApiError api_initData(tApiData* data);

// Add a person into the data if it does not exist
tApiError api_addPerson(tApiData* data, tCSVEntry entry);

// Add a subscription if it does not exist
tApiError api_addSubscription(tApiData* data, tCSVEntry entry);

// Add a film if it does not exist
tApiError api_addFilm(tApiData* data, tCSVEntry entry);

// Get the number of people registered on the application
int api_peopleCount(tApiData data);

// Get the number of subscriptions registered on the application
int api_subscriptionsCount(tApiData data);

// Get the number of films registered on the application
int api_filmsCount(tApiData data);

// Get the number of free films registered on the application
int api_freeFilmsCount(tApiData data);

// Free all used memory
tApiError api_freeData(tApiData* data);

// Add a new entry
tApiError api_addDataEntry(tApiData* data, tCSVEntry entry);

// Get subscription data
tApiError api_getSubscription(tApiData data, int id, tCSVEntry *entry);

// Get film data
tApiError api_getFilm(tApiData data, const char* name, tCSVEntry *entry);

// Get free films data
tApiError api_getFreeFilms(tApiData data, tCSVData *freeFilms);

// Get films data by genre
tApiError api_getFilmsByGenre(tApiData data, tCSVData *films, int genre);

#endif // __UOCPLAY_API__H

/************ fin api.h *****************/

/*********** csv.h *****************/
#ifndef __CSV_H__
#define __CSV_H__

#include <stdbool.h>
#define CSV_SEPARATOR_CHAR ;

// Store one entry from a CSV file
typedef struct _tCSVEntry {
    int numFields;
    char* type;
    char** fields;    
} tCSVEntry;

// Store the content of a CSV file
typedef struct _tCSVData {
    tCSVEntry *entries;
    int count;
    bool isValid;
} tCSVData;

// Initialize the tCSVData structure
void csv_init(tCSVData* data);

// Initialize the tCSVEntry structure
void csv_initEntry(tCSVEntry* entry);

// Parse the contents of a CSV file
void csv_parse(tCSVData* data, const char* input, const char* type);

// Add a new entry to the CSV Data
void csv_addStrEntry(tCSVData* data, const char* entry, const char* type);

// Print the content of the CSV data structure
void csv_print(tCSVData data);

// Print the content of the CSV entry structure
void csv_printEntry(tCSVEntry entry);

// Parse the contents of a CSV line   "f1;f2;f3" =>  field_0 = f1, field_1 = f2, field_2 = f3
void csv_parseEntry(tCSVEntry* entry, const char* input, const char* type);

// Get the number of entries
bool csv_isValid(tCSVData data);

// Remove all data from structure
void csv_free(tCSVData* data);

// Remove all data from structure
void csv_freeEntry(tCSVEntry* entry);

// Get the number of entries
int csv_numEntries(tCSVData data);

// Get the type of information contained in the entry
const char* csv_getType(tCSVEntry* entry);

// Get an entry from the CSV data
tCSVEntry* csv_getEntry(tCSVData data, int position);

// Get the number of fields for a given entry
int csv_numFields(tCSVEntry entry);

// Get a field from the given entry as integer
int csv_getAsInteger(tCSVEntry entry, int position);

// Get a field from the given entry as string. The value is copied to the provided buffer with provided maximum length
void csv_getAsString(tCSVEntry entry, int position, char* buffer, int length);

// Get a field from the given entry as integer
float csv_getAsReal(tCSVEntry entry, int position);

// Compare if two entries are the same
bool csv_equalsEntry(tCSVEntry entry1, tCSVEntry entry2);

// Compare if two data objects are the same
bool csv_equals(tCSVData data1, tCSVData data2);

#endif

/************ fin csv.h *****************/

/*********** date.h *****************/
#ifndef __DATE_H__
#define __DATE_H__
#include <stdbool.h>

// Length of the date
#define DATE_LENGTH 10
// Length of the time
#define TIME_LENGTH 5

typedef struct _tDate {    
    int day; 
    int month;
    int year;
} tDate;

typedef struct _tTime {
    int hour; 
    int minutes;
} tTime;

typedef struct _tDateTime {
    tDate date;
    tTime time;    
} tDateTime;

// Copy a time from src to dst
void time_cpy(tTime *dst, tTime src);

// Parse a tDate from string information
void date_parse(tDate* date, const char* text);

// Copy a date from src to dst
void date_cpy(tDate *dst, tDate src);

// Compare two dates
int date_cmp(tDate date1, tDate date2);

// Parse a tDateTime from string information
void dateTime_parse(tDateTime* dateTime, const char* date, const char* time);

// Compare two tDateTime structures and return -1 if dateTime1<dateTime2, 0 if equals and 1 if dateTime1>dateTime2.
int dateTime_cmp(tDateTime dateTime1, tDateTime dateTime2);

// Compare two tDateTime structures and return true if they contain the same value or false otherwise.
bool dateTime_equals(tDateTime dateTime1, tDateTime dateTime2);

#endif // __DATE_H__
/************ fin date.h *****************/

/*********** error.h *****************/
#ifndef __UOCHEALTHCENTER_ERROR__H
#define __UOCHEALTHCENTER_ERROR__H

// Define error codes
enum _tApiError
{
    E_SUCCESS = 0, // No error
    E_NOT_IMPLEMENTED = -1, // Called method is not implemented
    E_FILE_NOT_FOUND = -2, // File not found
    E_INVALID_ENTRY_TYPE = -3, // Invalid entry type
    E_INVALID_ENTRY_FORMAT = -4, // Invalid entry format
    E_MEMORY_ERROR = -5, // Memory error 
	E_FILM_DUPLICATED = -6, // Film duplicated
	E_FILM_NOT_FOUND = -7, // Film not found
	E_PERSON_DUPLICATED = -8, // Person duplicated
	E_PERSON_NOT_FOUND = 9, // Person not found
	E_SUBSCRIPTION_DUPLICATED = 10, // Subscription duplicated
	E_SUBSCRIPTION_NOT_FOUND = 11, // Subscription not found
};

// Define an error type
typedef enum _tApiError tApiError;

#endif // __UOCHEALTHCENTER_ERRORS__H
/************ fin error.h *****************/

/*********** film.h *****************/
#ifndef __FILM_H__
#define __FILM_H__
#include <stdbool.h>
#include "csv.h"
#include "date.h"
#include "error.h"

#define RATING_MIN 0.0
#define RATING_MAX 5.0

#define NUM_FIELDS_FILM 6

typedef enum {
	GENRE_FIRST = 0,
	
	GENRE_ACTION = GENRE_FIRST,	// 0
	GENRE_COMEDY,				// 1
	GENRE_DRAMA,				// 2
	GENRE_HORROR,				// 3
	GENRE_SCIENCE_FICTION,		// 4
	
	GENRE_END					// Max number of genres, used to check maximum values or iterate through them
} tFilmGenre;

typedef struct _tFilm {
	char* name;
	tTime duration;
	tFilmGenre genre;
	tDate release;
	float rating;
	bool isFree;
} tFilm;

typedef struct _tFilmListNode {
	tFilm elem;
	struct _tFilmListNode *next;
} tFilmListNode;

typedef struct _tFilmList {
	tFilmListNode *first;
	tFilmListNode *last;
	int count;
} tFilmList;

typedef struct _tFreeFilmListNode {
	tFilm *elem;
	struct _tFreeFilmListNode *next;
} tFreeFilmListNode;

typedef struct _tFreeFilmList {
	tFreeFilmListNode *first;
	tFreeFilmListNode *last;
	int count;
} tFreeFilmList;

typedef struct _tFilmCatalog {
	tFilmList filmList;
	tFreeFilmList freeFilmList;
} tCatalog;

//////////////////////////////////
// Available methods
//////////////////////////////////

// Parse input from CSVEntry
void film_parse(tFilm* data, tCSVEntry entry);

// Initialize a film
void film_init(tFilm* data, const char* name, tTime duration, tFilmGenre genre, tDate release, float rating, bool isFree);

// Copy a film from src to dst
void film_cpy(tFilm* dst, tFilm src);

// Get film data using a string
void film_get(tFilm data, char* buffer);

// Remove the data from a film
void film_free(tFilm* data);

// Initialize the films list
tApiError filmList_init(tFilmList* list);

// Add a new film to the list
tApiError filmList_add(tFilmList* list, tFilm film);

// Remove a film from the list
tApiError filmList_del(tFilmList* list, const char* name);

// Return a pointer to the film
tFilm* filmList_find(tFilmList list, const char* name);

// Remove the films from the list
tApiError filmList_free(tFilmList* list);

// Initialize the free films list
tApiError freeFilmList_init(tFreeFilmList* list);

// Add a new free film to the list
tApiError freeFilmList_add(tFreeFilmList* list, tFilm* film);

// Remove a free film from the list
tApiError freeFilmList_del(tFreeFilmList* list, const char* name);

// Return a pointer to the free film
tFilm* freeFilmList_find(tFreeFilmList list, const char* name);

// Remove the free films from the list
tApiError freeFilmsList_free(tFreeFilmList* list);

// Initialize the films catalog
tApiError catalog_init(tCatalog* catalog);

// Add a new film to the catalog
tApiError catalog_add(tCatalog* catalog, tFilm film);

// Remove a film from the catalog
tApiError catalog_del(tCatalog* catalog, const char* name);

// Return the number of total films
int catalog_len(tCatalog catalog);

// Return the number of free films
int catalog_freeLen(tCatalog catalog);

// Remove the films from the catalog
tApiError catalog_free(tCatalog* catalog);

////////////////////////////////////////////

#endif

/************ fin film.h *****************/

/*********** person.h *****************/
#ifndef __PERSON_H__
#define __PERSON_H__
#include "csv.h"
#include "date.h"
#include "error.h"

#define NUM_FIELDS_PERSON 8

typedef struct _tPerson {
    char* document;
    char* name;
    char* surname;
    char* phone;
    char* email;
    char* address;
    char* cp;
    tDate birthday;
} tPerson;

typedef struct _tPeople {
    tPerson* elems;
    int count;
} tPeople;

//////////////////////////////////
// Available methods
//////////////////////////////////

// Parse input from CSVEntry
void person_parse(tPerson* data, tCSVEntry entry);

// Copy the data from the source to destination
void person_cpy(tPerson* destination, tPerson source);

// Remove the data from a person
void person_free(tPerson* data);

// Initialize the people data
tApiError people_init(tPeople* data);

// Return the number of people
int people_count(tPeople data);

// Add a new person
tApiError people_add(tPeople* data, tPerson person);

// Remove a person
tApiError people_del(tPeople* data, const char *document);

// Return the position of a person with provided document. -1 if it does not exist
int people_find(tPeople data, const char* document);

// Print the person data
void people_print(tPeople data);

// Remove the data from all persons
tApiError people_free(tPeople* data);

////////////////////////////////////////////

#endif

/************ fin person.h *****************/

/*********** subscription.h *****************/
#ifndef __SUBSCRIPTION_H__
#define __SUBSCRIPTION_H__
#include "csv.h"
#include "date.h"
#include "error.h"
#include "person.h"

#define MAX_DOCUMENT 9
#define MAX_PLAN 250

#define NUM_FIELDS_SUBSCRIPTION 7

typedef struct _tSubscription {
    int id;
    char document[MAX_DOCUMENT + 1];
    tDate start_date;
    tDate end_date;
    char plan[MAX_PLAN + 1];
    float price;
    int numDevices;
} tSubscription;

typedef struct _tSubscriptions {
    tSubscription *elems;
    int count;
} tSubscriptions;

//////////////////////////////////
// Available methods
//////////////////////////////////

// Parse input from CSVEntry
void subscription_parse(tSubscription* data, tCSVEntry entry);

// Copy the data from the source to destination (individual data)
void subscription_cpy(tSubscription* destination, tSubscription source);

// Get subscription data using a string
void subscription_get(tSubscription data, char* buffer);

// Initialize subscriptions data
tApiError subscriptions_init(tSubscriptions* data);

// Return the number of subscriptions
int subscriptions_len(tSubscriptions data);

// Add a new subscription
tApiError subscriptions_add(tSubscriptions* data, tPeople people, tSubscription subscription);

// Remove a subscription
tApiError subscriptions_del(tSubscriptions* data, int id);

// Get subscription data of position index using a string
void subscriptions_get(tSubscriptions data, int index, char* buffer);

// Returns the position of a subscription looking for id's subscription. -1 if it does not exist
int subscriptions_find(tSubscriptions data, int id);

// Print subscriptions data
void subscriptions_print(tSubscriptions data);

// Remove all elements
tApiError subscriptions_free(tSubscriptions* data);

////////////////////////////////////////////

#endif

/************ fin subscription.h *****************/

/*********** test.c *****************/
#include <assert.h>
#include <string.h>
#include "test_data.h"
#include "test.h"
#include "test_pr1.h"


// Write data to file
void save_data(const char* filename, const char* data) {
    FILE *fout;
    fout = fopen(filename, "w");
    assert(fout != NULL);
    fwrite(data, strlen(data), 1, fout);
    fclose(fout);
}


// Run all available tests
void testSuite_run(tTestSuite* test_suite, const char* input, const char* readme) {    
    const char* default_readme = "../README.txt";    
    const char* filename;
    
    assert(test_suite != NULL);
    
    // Load the README.txt file
    if (readme == NULL) {
        testSuite_load_learner(test_suite, default_readme);
    } else {
        testSuite_load_learner(test_suite, readme);
    }
    
    //////////////////////
    // Run tests for PR1
    //////////////////////
    
    // If no file is provided, use default data for PR1
    if (input == NULL) {
        filename = "test_data_pr1.csv";
        save_data(filename, test_data_pr1_str);        
    } else {
        filename = input;
    }
    // Run tests
    run_pr1(test_suite, filename);
}

/************ fin test.c *****************/

/*********** test_pr1.c *****************/
#include "test_pr1.h"
#include "api.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>

// Run all tests for PR1
bool run_pr1(tTestSuite *test_suite, const char *input) {
    bool ok = true;
    tTestSection* section = NULL;

    assert(test_suite != NULL);

    testSuite_addSection(test_suite, "PR1", "Tests for PR1 exercices");

    section = testSuite_getSection(test_suite, "PR1");
    assert(section != NULL);

    ok = run_pr1_ex1(section, input);
    ok = run_pr1_ex2(section, input) && ok;
    ok = run_pr1_ex3(section, input) && ok;
    ok = run_pr1_ex4(section, input) && ok;

    return ok;
}

// Run all tests for Exercice 1 of PR1
bool run_pr1_ex1(tTestSection *test_section, const char *input) {
	bool passed = true, failed = false;
	const char *version;

	/////////////////////////////
	/////  PR1 EX1 TEST 1  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX1_1", "Read version information.");
	// Get the version
	version = api_version();
	if (strcmp(version, "UOC PP 20242") != 0) {
		failed = true;
		passed = false;
	}
	end_test(test_section, "PR1_EX1_1", !failed);

	return passed;
}

// Run all tests for Exercice 2 of PR1
bool run_pr1_ex2(tTestSection *test_section, const char *input) {
	tApiError error;
	tTime duration;
	tDate release;
	tFilm film1, film2, film3, film4;
	tCatalog catalog;
	
	bool passed = true;
	bool failed = false;
	bool fail_all = false;
	
	// film1
	duration.hour = 2;
	duration.minutes = 49;
	release.day = 7;
	release.month = 11;
	release.year = 2014;
	film_init(&film1, "Interstellar", duration, 4, release, 4.8f, false);

	// film2
	duration.hour = 2;
	duration.minutes = 0;
	release.day = 15;
	release.month = 5;
	release.year = 2015;
	film_init(&film2, "Mad Max: Fury Road", duration, 0, release, 4.5f, false);

	// film3
	duration.hour = 3;
	duration.minutes = 9;
	release.day = 10;
	release.month = 12;
	release.year = 1999;
	film_init(&film3, "The Green Mile", duration, 2, release, 4.8f, true);

	// film4
	duration.hour = 1;
	duration.minutes = 57;
	release.day = 15;
	release.month = 12;
	release.year = 2006;
	film_init(&film4, "The Pursuit of Happyness", duration, 2, release, 4.4f, true);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 1  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_1", "Initialize the catalog data structure");
	// Initialize the catalog
	error = catalog_init(&catalog);
	if (error != E_SUCCESS) {
		failed = true;
		passed = false;
		fail_all = true;
	} else {
		if (catalog.filmList.first != NULL || catalog.filmList.last != NULL || catalog.filmList.count != 0 
		 || catalog.freeFilmList.first != NULL || catalog.freeFilmList.last != NULL || catalog.freeFilmList.count != 0) {
			failed = true;
			passed = false;
			fail_all = true;
		}
	}
	end_test(test_section, "PR1_EX2_1", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 2  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_2", "Add a film to an empty catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Add a film to an empty catalog
		error = catalog_add(&catalog, film1);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first != NULL || catalog.freeFilmList.last != NULL || catalog.freeFilmList.count != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next != NULL || strcmp(catalog.filmList.first->elem.name, film1.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_2", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 3  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_3", "Add a free film to a non-empty catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Add a free film to a non-empty catalog
		error = catalog_add(&catalog, film3);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 2) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first == NULL || catalog.freeFilmList.last == NULL || catalog.freeFilmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next == NULL || strcmp(catalog.filmList.first->elem.name, film1.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next->next != NULL || strcmp(catalog.filmList.first->next->elem.name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first->next != NULL || strcmp(catalog.freeFilmList.first->elem->name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (&(catalog.filmList.first->next->elem) != catalog.freeFilmList.first->elem) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_3", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 4  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_4", "Add a duplicated film to the catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Add a duplicated film to the catalog
		error = catalog_add(&catalog, film1);
		if (error != E_FILM_DUPLICATED) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 2) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first == NULL || catalog.freeFilmList.last == NULL || catalog.freeFilmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next == NULL || strcmp(catalog.filmList.first->elem.name, film1.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next->next != NULL || strcmp(catalog.filmList.first->next->elem.name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first->next != NULL || strcmp(catalog.freeFilmList.first->elem->name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (&(catalog.filmList.first->next->elem) != catalog.freeFilmList.first->elem) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_4", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 5  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_5", "Remove a non-existing film from the catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Remove a non-existing film from the catalog
		error = catalog_del(&catalog, film2.name);
		if (error != E_FILM_NOT_FOUND) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 2) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first == NULL || catalog.freeFilmList.last == NULL || catalog.freeFilmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next == NULL || strcmp(catalog.filmList.first->elem.name, film1.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next->next != NULL || strcmp(catalog.filmList.first->next->elem.name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first->next != NULL || strcmp(catalog.freeFilmList.first->elem->name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (&(catalog.filmList.first->next->elem) != catalog.freeFilmList.first->elem) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_5", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 6  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_6", "Remove a film from the catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Remove a film from the catalog
		error = catalog_del(&catalog, film1.name);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first == NULL || catalog.freeFilmList.last == NULL || catalog.freeFilmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next != NULL || strcmp(catalog.filmList.first->elem.name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first->next != NULL || strcmp(catalog.freeFilmList.first->elem->name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (&(catalog.filmList.first->elem) != catalog.freeFilmList.first->elem) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_6", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 7  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_7", "Remove a free film from the catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Remove a free film from the catalog
		error = catalog_del(&catalog, film3.name);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first != NULL || catalog.filmList.last != NULL || catalog.filmList.count != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first != NULL || catalog.freeFilmList.last != NULL || catalog.freeFilmList.count != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_7", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 8  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_8", "Get the number of films");
	if (fail_all) {
		failed = true;
	} else {
		// Add films into the catalog
		catalog_add(&catalog, film1);
		catalog_add(&catalog, film2);
		catalog_add(&catalog, film3);
		catalog_add(&catalog, film4);
		
		if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 4) {
			failed = true;
			passed = false;
			fail_all = true;
		} else if (catalog.freeFilmList.first == NULL || catalog.freeFilmList.last == NULL || catalog.freeFilmList.count != 2) {
			failed = true;
			passed = false;
			fail_all = true;
		} else if (catalog_len(catalog) != 4 || catalog_freeLen(catalog) != 2) {
			failed = true;
			passed = false;
			fail_all = true;
		}
	}
	end_test(test_section, "PR1_EX2_8", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 8  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_9", "Remove all films from the catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Remove all the data from the catalog
		error = catalog_free(&catalog);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		} else if (catalog.filmList.first != NULL || catalog.filmList.last != NULL || catalog.filmList.count != 0) {
			failed = true;
			passed = false;
			fail_all = true;
		} else if (catalog.freeFilmList.first != NULL || catalog.freeFilmList.last != NULL || catalog.freeFilmList.count != 0) {
			failed = true;
			passed = false;
			fail_all = true;
		}
	}
	end_test(test_section, "PR1_EX2_9", !failed);
	
	// Release all data
	catalog_free(&catalog);
	film_free(&film1);
	film_free(&film2);
	film_free(&film3);
	film_free(&film4);
	
	return passed;
}

// Run all tests for Exercice 3 of PR1
bool run_pr1_ex3(tTestSection *test_section, const char *input) {
	tApiData data;
	tApiError error;
	tCSVEntry entry;
	int nPeople;
	int nSubscriptions;
	int nFilms;
	int nFreeFilms;

	bool passed = true;
	bool failed = false;
	bool fail_all = false;

	/////////////////////////////
	/////  PR1 EX3 TEST 1  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_1", "Initialize the API data structure");
	// Initialize the data
	error = api_initData(&data);
	if (error != E_SUCCESS) {
		failed = true;
		passed = false;
		fail_all = true;
	}
	end_test(test_section, "PR1_EX3_1", !failed);

	/////////////////////////////
	/////  PR1 EX3 TEST 2  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_2", "Add an invalid person");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "98765432J;Hendrik;Lorentz;987654321;hendrik.lorentz@example.com;his street, 5;00001;27/08/1954", "PERSONA");
		
		// Add an invalid person type
		error = api_addPerson(&data, entry);
		if (error != E_INVALID_ENTRY_TYPE) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "98765432J;Hendrik;Lorentz;987654321;hendrik.lorentz@example.com;his street, 5;00001;27/08/1954;oops", "PERSON");
		
		// Add an invalid person format
		error = api_addPerson(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "98765432J;Hendrik;Lorentz;987654321;hendrik.lorentz@example.com;his street, 5;27/08/1954", "PERSON");
		
		// Add an invalid person format
		error = api_addPerson(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_2", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 3  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_3", "Add a duplicated person");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "98765432J;Hendrik;Lorentz;987654321;hendrik.lorentz@example.com;his street, 5;00001;27/08/1954", "PERSON");
		
		// Add a valid person
		error = api_addPerson(&data, entry);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		if (!failed) {
			// Add a duplicated person
			error = api_addPerson(&data, entry);
			
			if (error != E_PERSON_DUPLICATED) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_3", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 4  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_4", "Add an invalid subscription");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "1;98765432J;01/01/2025;31/12/2025;Free;0;1", "SUBSCRIPTIO");
		
		// Add an invalid subscription type
		error = api_addSubscription(&data, entry);
		if (error != E_INVALID_ENTRY_TYPE) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "1;98765432J;01/01/2025;31/12/2025;Free;0;1;oops", "SUBSCRIPTION");
		
		// Add an invalid subscription format
		error = api_addSubscription(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "1;98765432J;01/01/2025;31/12/2025;Free;1", "SUBSCRIPTION");
		
		// Add an invalid subscription format
		error = api_addSubscription(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_4", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 5  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_5", "Add a duplicated subscription");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "1;98765432J;01/01/2025;31/12/2025;Free;0;1", "SUBSCRIPTION");
		
		// Add a valid subscription
		error = api_addSubscription(&data, entry);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		if (!failed) {
			// Add a duplicated subscription
			error = api_addSubscription(&data, entry);
			
			if (error != E_SUBSCRIPTION_DUPLICATED) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_5", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 6  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_6", "Add a subscription with non-existing person");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "2;00000000T;01/01/2025;31/12/2025;Free;0;1", "SUBSCRIPTION");
		
		// Add a valid subscription with non-exist person
		error = api_addSubscription(&data, entry);
		if (error != E_PERSON_NOT_FOUND) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_6", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 7  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_7", "Add an invalid film");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "Interstellar;02:49;4;07/11/2014;4.8;0", "FILMO");
		
		// Add an invalid film type
		error = api_addFilm(&data, entry);
		if (error != E_INVALID_ENTRY_TYPE) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "Interstellar;02:49;4;07/11/2014;4.8;0;oops", "FILM");
		
		// Add an invalid film format
		error = api_addFilm(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "Interstellar;4;07/11/2014;4.8;0", "FILM");
		
		// Add an invalid film format
		error = api_addFilm(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_7", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 8  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_8", "Add a duplicated film");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "Interstellar;02:49;4;07/11/2014;4.8;0", "FILM");
		
		// Add a valid film
		error = api_addFilm(&data, entry);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		if (!failed) {
			// Add a duplicated film
			error = api_addFilm(&data, entry);
			
			if (error != E_FILM_DUPLICATED) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_8", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 9  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_9", "Check the number of persons");
	if (fail_all) {
		failed = true;
	} else {
		nPeople = api_peopleCount(data);
		if (nPeople != 1) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			// Valid person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "33365111X;Marie;Curie;+33123456789;marie.curie@example.com;Radium street, 88;54321;07/10/1867", "PERSON");
			api_addPerson(&data, entry);
			csv_freeEntry(&entry);
			
			// Valid person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "55565432Z;Nils;Gustaf Dalen;555123123;nils.gustaf@example.com;Picadilly street, 123;12345;25/11/1972", "PERSON");
			api_addPerson(&data, entry);
			csv_freeEntry(&entry);
			
			// Duplicated person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "55565432Z;Nils;Gustaf Dalen;555123123;nils.gustaf@example.com;Picadilly street, 123;12345;25/11/1972", "PERSON");
			api_addPerson(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "Nils;Gustaf Dalen;555123123;nils.gustaf@example.com;Picadilly street, 123;12345;25/11/1972", "PERSON");
			api_addPerson(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "55565432Z;Nils;Gustaf Dalen;555123123;nils.gustaf@example.com;Picadilly street, 123;12345;25/11/1972", "PERSONA");
			api_addPerson(&data, entry);
			csv_freeEntry(&entry);
			
			nPeople = api_peopleCount(data);
			if (nPeople != 3) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX3_9", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 10  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_10", "Check the number of subscriptions");
	if (fail_all) {
		failed = true;
	} else {
		nSubscriptions = api_subscriptionsCount(data);
		if (nSubscriptions != 1) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			// Valid subscription
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "2;33365111X;01/05/2025;30/04/2026;Standard;29.95;3", "SUBSCRIPTION");
			api_addSubscription(&data, entry);
			csv_freeEntry(&entry);
			
			// Duplicated subscription
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "2;33365111X;01/05/2025;30/04/2026;Standard;29.95;3", "SUBSCRIPTION");
			api_addSubscription(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid subscription
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "3;33365111X;01/05/2025;30/04/2026;Standard;29.95;3", "SUBSCRIPTIONA");
			api_addSubscription(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid subscription
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "3;33365111X;01/05/2025;30/04/2026;Standard;29.95", "SUBSCRIPTION");
			api_addSubscription(&data, entry);
			csv_freeEntry(&entry);
			
			// Non-existing person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "3;00000000T;01/05/2025;30/04/2026;Standard;29.95;3", "SUBSCRIPTION");
			api_addSubscription(&data, entry);
			csv_freeEntry(&entry);
			
			nSubscriptions = api_subscriptionsCount(data);
			if (nSubscriptions != 2) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX3_10", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 11 //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_11", "Check the number of films");
	if (fail_all) {
		failed = true;
	} else {
		nFilms = api_filmsCount(data);
		nFreeFilms = api_freeFilmsCount(data);
		if (nFilms != 1 || nFreeFilms != 0) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			// Valid film
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "Blade Runner 2049;02:44;4;06/10/2017;4.6;1", "FILM");
			api_addFilm(&data, entry);
			csv_freeEntry(&entry);
			
			// Valid film
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "The Matrix;02:16;4;31/03/1999;4.9;1", "FILM");
			api_addFilm(&data, entry);
			csv_freeEntry(&entry);
			
			// Duplicated film
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "The Matrix;02:16;4;31/03/1999;4.9;1", "FILM");
			api_addFilm(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid film
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "Inception;02:28;0;16/07/2010;4.7;1;oops", "FILM");
			api_addFilm(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid film
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "Inception;02:28;0;16/07/2010;4.7;1", "FILMO");
			api_addFilm(&data, entry);
			csv_freeEntry(&entry);
			
			nFilms = api_filmsCount(data);
			nFreeFilms = api_freeFilmsCount(data);
			if (nFilms != 3 || nFreeFilms != 2) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX3_11", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 12 //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_12", "Free API data");
	if (fail_all) {
		failed = true;
	} else {
		error = api_freeData(&data);
		nPeople = api_peopleCount(data);
		nSubscriptions = api_subscriptionsCount(data);
		nFilms = api_filmsCount(data);
		nFreeFilms = api_freeFilmsCount(data);
		if (error != E_SUCCESS || nPeople != 0 || nSubscriptions != 0 || nFilms != 0 || nFreeFilms != 0) {
			failed = true;
			passed = false;
			fail_all = true;
		}
	}
	end_test(test_section, "PR1_EX2_12", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 13 //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_13", "Load data from file");
	if (fail_all) {
		failed = true;
	} else {
		error = api_loadData(&data, input, true);
		nPeople = api_peopleCount(data);
		nSubscriptions = api_subscriptionsCount(data);
		nFilms = api_filmsCount(data);
		nFreeFilms = api_freeFilmsCount(data);
		if (error != E_SUCCESS || nPeople != 5 || nSubscriptions != 5 || nFilms != 15 || nFreeFilms != 11) {
			failed = true;
			passed = false;
			fail_all = true;
		}
	}
	end_test(test_section, "PR1_EX2_13", !failed);
	
	// Release all data
	api_freeData(&data);

	return passed;
}

// Run all tests for Exercice 4 of PR1
bool run_pr1_ex4(tTestSection *test_section, const char *input) {
	tApiData data;
	tApiError error;
	tCSVEntry entry;
	tCSVEntry refEntry;
	tCSVData report;
	tCSVData refReport;
	int nPeople;
	int nSubscriptions;
	int nFilms;
	int nFreeFilms;
	bool passed = true;
	bool failed = false;
	bool fail_all = false;

	// Initialize the data
	error = api_initData(&data);
	if (error != E_SUCCESS) {
		passed = false;
		fail_all = true;
	}

	if (!fail_all) {
		error = api_loadData(&data, input, true);
		nPeople = api_peopleCount(data);
		nSubscriptions = api_subscriptionsCount(data);
		nFilms = api_filmsCount(data);
		nFreeFilms = api_freeFilmsCount(data);
		if (error != E_SUCCESS || nPeople != 5 || nSubscriptions != 5 || nFilms != 15 || nFreeFilms != 11) {
			passed = false;
			fail_all = true;
		}
	}

	/////////////////////////////
	/////  PR1 EX4 TEST 1  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_1", "Request a missing subscription");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		error = api_getSubscription(data, 999, &entry);
		if (error != E_SUBSCRIPTION_NOT_FOUND) {
			failed = true;
			passed = false;
		}
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX4_1", !failed);

	/////////////////////////////
	/////  PR1 EX4 TEST 2  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_2", "Request a valid subscription");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_initEntry(&refEntry);
		csv_parseEntry(&refEntry, "5;47051307Z;01/01/2023;31/12/2028;Premium;29.95;3", "SUBSCRIPTION");
		error = api_getSubscription(data, 5, &entry);
		if (error != E_SUCCESS || !csv_equalsEntry(entry, refEntry)) {
			failed = true;
			passed = false;
		}
		csv_freeEntry(&entry);
		csv_freeEntry(&refEntry);
	}
	end_test(test_section, "PR1_EX4_2", !failed);
 
	/////////////////////////////
	/////  PR1 EX4 TEST 3  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_3", "Request a missing film");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		error = api_getFilm(data, "Unknown", &entry);
		if (error != E_FILM_NOT_FOUND) {
			failed = true;
			passed = false;
		}
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX4_3", !failed);

	/////////////////////////////
	/////  PR1 EX4 TEST 4  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_4", "Request a valid film");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_initEntry(&refEntry);
		csv_parseEntry(&refEntry, "The Pursuit of Happyness;01:57;2;15/12/2006;4.4;1", "FILM");
		error = api_getFilm(data, "The Pursuit of Happyness", &entry);
		if (error != E_SUCCESS || !csv_equalsEntry(entry, refEntry)) {
			failed = true;
			passed = false;
		}
		csv_freeEntry(&entry);
		csv_freeEntry(&refEntry);
	}
	end_test(test_section, "PR1_EX4_4", !failed);

	/////////////////////////////
	/////  PR1 EX4 TEST 5  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_5", "Get free films");
	if (fail_all) {
		failed = true;
	} else {
		csv_init(&report);
		csv_init(&refReport);

		csv_addStrEntry(&refReport, "Blade Runner 2049;02:44;4;06/10/2017;4.6;1", "FILM");	
		csv_addStrEntry(&refReport, "The Matrix;02:16;4;31/03/1999;4.9;1", "FILM");
		csv_addStrEntry(&refReport, "Inception;02:28;0;16/07/2010;4.7;1", "FILM");
		csv_addStrEntry(&refReport, "Die Hard;02:12;0;15/07/1988;4.3;1", "FILM");
		csv_addStrEntry(&refReport, "Superbad;01:53;1;17/08/2007;4.0;1", "FILM");
		csv_addStrEntry(&refReport, "Monty Python and the Holy Grail;01:31;1;03/04/1975;4.8;1", "FILM");
		csv_addStrEntry(&refReport, "The Green Mile;03:09;2;10/12/1999;4.8;1", "FILM");
		csv_addStrEntry(&refReport, "The Pursuit of Happyness;01:57;2;15/12/2006;4.4;1", "FILM");
		csv_addStrEntry(&refReport, "The Shining;02:26;3;23/05/1980;4.5;1", "FILM");
		csv_addStrEntry(&refReport, "A Nightmare on Elm Street;01:31;3;09/11/1984;4.1;1", "FILM");
		csv_addStrEntry(&refReport, "Get Out;01:44;3;24/02/2017;4.3;1", "FILM");

		error = api_getFreeFilms(data, &report);
		if (error != E_SUCCESS || !csv_equals(report, refReport)) {
			failed = true;
			passed = false;
		}
		csv_free(&report);
		csv_free(&refReport);
	}
	end_test(test_section, "PR1_EX4_5", !failed);

	/////////////////////////////
	/////  PR1 EX4 TEST 6  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_6", "Get films by genre");
	if (fail_all) {
		failed = true;
	} else {
		csv_init(&report);
		csv_init(&refReport);		

		csv_addStrEntry(&refReport, "Interstellar;02:49;4;07/11/2014;4.8;0" ,"FILM");
		csv_addStrEntry(&refReport, "Blade Runner 2049;02:44;4;06/10/2017;4.6;1" ,"FILM");
		csv_addStrEntry(&refReport, "The Matrix;02:16;4;31/03/1999;4.9;1" ,"FILM");

		error = api_getFilmsByGenre(data, &report, GENRE_SCIENCE_FICTION);
		if (error != E_SUCCESS || !csv_equals(report, refReport)) {
			failed = true;
			passed = false;
		}
		csv_free(&report);
		csv_free(&refReport);
		
		if (!failed) {
			csv_init(&report);
			csv_init(&refReport);		

			csv_addStrEntry(&refReport, "The Shining;02:26;3;23/05/1980;4.5;1" ,"FILM");
			csv_addStrEntry(&refReport, "A Nightmare on Elm Street;01:31;3;09/11/1984;4.1;1" ,"FILM");
			csv_addStrEntry(&refReport, "Get Out;01:44;3;24/02/2017;4.3;1" ,"FILM");

			error = api_getFilmsByGenre(data, &report, GENRE_HORROR);
			if (error != E_SUCCESS || !csv_equals(report, refReport)) {
				failed = true;
				passed = false;
			}
			csv_free(&report);
			csv_free(&refReport);
		}
	}
	end_test(test_section, "PR1_EX4_6", !failed);

	// Release all data
	api_freeData(&data);

	return passed;
}

/************ fin test_pr1.c *****************/

/*********** test_suite.c *****************/
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "test_suite.h"
#include <stdarg.h>

#ifdef DSLAB
#include "lsim.h"
#include "lsimLogger.h"
#endif

// Wait user key
void waitKey(tAppArguments parameters) {
    if (parameters.wait_on_exit) {
        printf("Press key to continue...");
        getchar();
    }
}

// Display help text
void help(const char* app_name) {
    printf("%s [--help] [--in <input_test_file>] [--out <output_file>] [--progress <progress_file>] [--readme <readme_file>]\n", app_name);
    printf("\t[%s] %s\n", "--help", "Show this help information.");
    printf("\t[%s] %s\n", "--no-wait", "Do not wait user key press on exit.");
    printf("\t[%s] %s\n", "--in", "Provide file with input test data in CSV format.");
    printf("\t[%s] %s\n", "--out", "Write the result of tests in a file in JSON format.");
    printf("\t[%s] %s\n", "--progress", "Write test progress in an output file.");
    printf("\t[%s] %s\n", "--readme", "Path to README.txt file.");
    printf("\t[%s] %s\n", "--hide-results", "Do not show tests results on the standard output.");
}

// Parse application arguments
bool parseArguments(tAppArguments* arguments, int argc, char** argv) {
    int i;

    // Initialize the arguments
    arguments->app_name = NULL;
    arguments->out_file = NULL;
    arguments->in_file = NULL;
    arguments->readme_file = NULL;
    arguments->progress_file = NULL;
    arguments->wait_on_exit = true;
    arguments->print_results_on_stdout = true;

    // Parse input arguments
    arguments->app_name = argv[0];
    for (i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--help") == 0) {
            help(argv[0]);
        }
        else if (strcmp(argv[i], "--no-wait") == 0) {
            arguments->wait_on_exit = false;
        }
        else if (strcmp(argv[i], "--in") == 0) {
            if (argc < i + 1) {
                help(argv[0]);
                return false;
            }
            arguments->in_file = argv[i + 1];
            i++;
        }
        else if (strcmp(argv[i], "--out") == 0) {
            if (argc < i + 1) {
                help(argv[0]);
                return false;
            }
            arguments->out_file = argv[i + 1];
            i++;
        }
        else if (strcmp(argv[i], "--progress") == 0) {
            if (argc < i + 1) {
                help(argv[0]);
                return false;
            }
            arguments->progress_file = argv[i + 1];
            i++;
        }
        else if (strcmp(argv[i], "--readme") == 0) {
            if (argc < i + 1) {
                help(argv[0]);
                return false;
            }
            arguments->readme_file = argv[i + 1];
            i++;
        }
        else if (strcmp(argv[i], "--hide-results") == 0) {
            arguments->print_results_on_stdout = false;
        }
    }

    return true;
}

// Initialize a test Suite
void testSuite_init(tTestSuite* object) {
    assert(object != NULL);
    object->learner.email = NULL;
    object->learner.username = NULL;
    object->learner.first_name = NULL;
    object->learner.last_name = NULL;
    object->learner.environment = NULL;
    object->learner.file_exists = false;
    object->numSections = 0;
    object->sections = NULL;
    object->progress_file = NULL;
}

// Set output progress file
void testSuite_set_progress_file(tTestSuite* object, char* progress_file) {
    object->progress_file = progress_file;
}

// Load learner data
bool testSuite_load_learner(tTestSuite* object, const char* file) {
    char buffer[BUFFER_SIZE];
    FILE* fin = NULL;
    int state;
    char* pos;

    assert(object != NULL);
    assert(file != NULL);

    fin = fopen(file, "r");
    if (fin == NULL) {
        object->learner.email = NULL;
        object->learner.username = NULL;
        object->learner.first_name = NULL;
        object->learner.last_name = NULL;
        object->learner.environment = NULL;
        object->learner.file_exists = false;
        return false;
    }

    state = 0;
    while (fgets(buffer, BUFFER_SIZE, fin)) {
        if (state == 0) {
            // Read email
            object->learner.email = (char*)malloc((strlen(buffer) + 1) * sizeof(char));
            memset(object->learner.email, 0, (strlen(buffer) + 1) * sizeof(char));
            strncpy(object->learner.email, buffer, strcspn(buffer, "\n\r"));
        }
        else if (state == 1) {
            // Read Surname, Name
            pos = strchr(buffer, ',');
            if (pos > 0) {
                // Copy the surnames
                object->learner.last_name = (char*)malloc((pos - buffer + 1) * sizeof(char));
                memset(object->learner.last_name, 0, (pos - buffer + 1) * sizeof(char));
                strncpy(object->learner.last_name, buffer, strcspn(buffer, ","));
                // Skip the comma
                pos++;
                // Skip initial blank spaces
                while (pos < &buffer[BUFFER_SIZE] && *pos == ' ') pos++;
                // Copy the first name
                object->learner.first_name = (char*)malloc((strlen(pos) + 1) * sizeof(char));
                memset(object->learner.first_name, 0, (strlen(pos) + 1) * sizeof(char));
                strncpy(object->learner.first_name, pos, strcspn(pos, "\n\r"));
            }
            else {
                object->learner.first_name = (char*)malloc((strlen(buffer) + 1) * sizeof(char));
                memset(object->learner.first_name, 0, (strlen(buffer) + 1) * sizeof(char));
                strncpy(object->learner.first_name, buffer, strlen(buffer));
            }
        }
        else if (state == 2) {
            object->learner.environment = (char*)malloc((strlen(buffer) + 1) * sizeof(char));
            strcpy(object->learner.environment, buffer);
        }
        else if (state > 2) {
            object->learner.environment = (char*)realloc(object->learner.environment, (strlen(object->learner.environment) + strlen(buffer) + 1) * sizeof(char));
            strcat(object->learner.environment, buffer);
        }
        state++;
    }

    object->learner.file_exists = true;

    fclose(fin);
    return true;
}

// Remove a test Suite
void testSuite_free(tTestSuite* object) {
    int i;
    assert(object != NULL);
    // Free learner data
    if (object->learner.email != NULL) {
        free(object->learner.email);
        object->learner.email = NULL;
    }
    if (object->learner.username != NULL) {
        free(object->learner.username);
        object->learner.username = NULL;
    }
    if (object->learner.first_name != NULL) {
        free(object->learner.first_name);
        object->learner.first_name = NULL;
    }
    if (object->learner.last_name != NULL) {
        free(object->learner.last_name);
        object->learner.last_name = NULL;
    }
    if (object->learner.environment != NULL) {
        free(object->learner.environment);
        object->learner.environment = NULL;
    }
    object->learner.file_exists = false;
    // Free test data
    if (object->sections != NULL) {
        for (i = 0; i < object->numSections; i++) {
            testSection_free(&(object->sections[i]));
        }
        free(object->sections);
    }
    object->progress_file = NULL;
}

// Add a test Section
void testSuite_addSection(tTestSuite* object, const char* code, const char* title) {
    assert(object != NULL);
    object->numSections++;
    if (object->sections == NULL) {
        object->sections = (tTestSection*)malloc(object->numSections * sizeof(tTestSection));
    }
    else {
        object->sections = (tTestSection*)realloc(object->sections, object->numSections * sizeof(tTestSection));
    }
    assert(object->sections != NULL);
    testSection_init(&(object->sections[object->numSections - 1]), code, title);
    if (object->progress_file != NULL) {
        object->sections[object->numSections - 1].progress_file = object->progress_file;
    }
}

// Add a test
void testSuite_addTest(tTestSuite* object, const char* section_code, const char* code, const char* description, tTestResult result) {
    tTestSection* section = NULL;
    assert(object != NULL);
    assert(section_code != NULL);
    assert(code != NULL);
    assert(description != NULL);

    section = testSuite_getSection(object, section_code);
    assert(section != NULL);

    testSection_addTest(section, code, description, result);
}

// Update a test result
void testSuite_updateTest(tTestSuite* object, const char* section_code, const char* test_code, tTestResult result) {
    tTestSection* section = NULL;

    assert(object != NULL);
    assert(section_code != NULL);
    assert(test_code != NULL);

    section = testSuite_getSection(object, section_code);
    assert(section != NULL);

    testSection_updateTest(section, test_code, result);
}

// Get a pointer to a section
tTestSection* testSuite_getSection(tTestSuite* object, const char* section_code) {
    int i;

    assert(object != NULL);
    assert(section_code != NULL);
    for (i = 0; i < object->numSections; i++) {
        if (strcmp(object->sections[i].code, section_code) == 0) {
            return &(object->sections[i]);
        }
    }
    return NULL;
}

// Get a pointer to a test
tTest* testSuite_getTest(tTestSuite* object, const char* section_code, const char* test_code) {
    tTestSection* section = NULL;

    assert(object != NULL);
    assert(section_code != NULL);
    assert(test_code != NULL);
    section = testSuite_getSection(object, section_code);
    assert(section != NULL);

    if (section != NULL) {
        return testSection_getTest(section, test_code);
    }

    return NULL;
}

// Get test statistics
void testSuite_getStats(tTestSuite* object, int* total, int* passed, int* failed, int* not_implemented) {
    int i;
    int s_total, s_passed, s_failed, s_not_implemented;
    assert(object != NULL);
    assert(total != NULL);
    assert(passed != NULL);
    assert(failed != NULL);
    assert(not_implemented != NULL);

    *total = 0;
    *passed = 0;
    *failed = 0;
    *not_implemented = 0;
    for (i = 0; i < object->numSections; i++) {
        testSection_getStats(&(object->sections[i]), &s_total, &s_passed, &s_failed, &s_not_implemented);
        *total += s_total;
        *passed += s_passed;
        *failed += s_failed;
        *not_implemented += s_not_implemented;
    }
}

// Print test suite
void testSuite_print(tTestSuite* object, tAppArguments parameters) {
    int i;
    int total, passed, failed, not_implemented;
    tBuffer* buffer = NULL;

    assert(object != NULL);

    // Reserve memory and open buffer
    buffer = (tBuffer*)malloc(sizeof(tBuffer));
    assert(buffer != NULL);
    open_buffer(buffer);

    // Print the header
    if (object->learner.file_exists) {
        bprintf(buffer, "\n=========================================================================\n");
        if (object->learner.first_name != NULL && object->learner.last_name != NULL) {
            bprintf(buffer, "\t Name: %s %s\n", object->learner.first_name, object->learner.last_name);
        }
        else {
            bprintf(buffer, "\t Name: <not provided>\n");
        }
        if (object->learner.email != NULL) {
            bprintf(buffer, "\t Email: %s\n", object->learner.email);
        }
        else {
            bprintf(buffer, "\t Email: <not provided>\n");
        }
        bprintf(buffer, "=========================================================================\n");
    }
    else {
        bprintf(buffer, "\n=========================================================================\n");
        bprintf(buffer, "\t NO LEARNER DATA\n");
        bprintf(buffer, "=========================================================================\n");
    }

    testSuite_getStats(object, &total, &passed, &failed, &not_implemented);

    bprintf(buffer, "\n=========================================================================\n");
    bprintf(buffer, "\t TEST RESULTS\n");
    bprintf(buffer, "=========================================================================\n");
    if (object->numSections == 0) {
        bprintf(buffer, "NO TEST DEFINED\n");
    }
    else {
        for (i = 0; i < object->numSections; i++) {
            testSection_print(&(object->sections[i]), buffer);
        }
    }
    bprintf(buffer, "\n=========================================================================\n");
    if (total > 0) {
        bprintf(buffer, "Total Tests: %d\n", total);
        bprintf(buffer, "Passed Tests: %d ( %2.02f %% )\n", passed, ((float)passed / (float)total) * 100.0);
        bprintf(buffer, "Failed Tests: %d ( %2.02f %% )\n", failed, ((float)failed / (float)total) * 100.0);
        //fprintf(buffer, "Not Implemented: %d ( %2.02f %% )\n", not_implemented, ((float)not_implemented/(float)total)*100.0);
        bprintf(buffer, "=========================================================================\n");
    }

    if (parameters.print_results_on_stdout)
        printf("%s", buffer->data);

#ifdef DSLAB
    float percent = 0.0;
    char summary[100];
    if (total > 0)
        percent = (float)passed / total * 100.0;
    sprintf(summary, "\tPassed %d of %d [%0.2f%%]\n", passed, total, percent);
    bool is_Ok = ((float)passed / (float)total) == 1.0;
    LSim_sendCorreccio(is_Ok, (char)percent, summary, buffer->data);
#endif

    // Close buffer and free memory
    close_buffer(buffer);
    free(buffer);
}

void write_nullable_field(FILE* fout, const char* value) {
    if (value == NULL) {
        fprintf(fout, "null");
    }
    else {
        fprintf(fout, "\"%s\"", value);
    }
}

// Export a test suite
void testSuite_export(tTestSuite* object, const char* output) {
    int i;
    int total, passed, failed, not_implemented;
    FILE* fout = NULL;

    assert(object != NULL);
    assert(output != NULL);

    fout = fopen(output, "w");
    assert(fout != NULL);

    fprintf(fout, "{ \"learner\": {\"first_name\": ");
    write_nullable_field(fout, object->learner.first_name);
    fprintf(fout, ", \"last_name\": ");
    write_nullable_field(fout, object->learner.last_name);
    fprintf(fout, ", \"email\": ");
    write_nullable_field(fout, object->learner.email);
    fprintf(fout, ", \"username\": ");
    write_nullable_field(fout, object->learner.username);
    fprintf(fout, ", \"environment\": ");
    write_nullable_field(fout, object->learner.environment);
    fprintf(fout, "}, ");

    testSuite_getStats(object, &total, &passed, &failed, &not_implemented);

    fprintf(fout, " \"total\": %d, \"passed\": %d, \"failed\": %d, \"not_implemented\": %d, \"sections\": [", total, passed, failed, not_implemented);

    for (i = 0; i < object->numSections; i++) {
        if (i > 0) {
            fprintf(fout, ", ");
        }
        testSection_export(&(object->sections[i]), fout);
    }

    fprintf(fout, "]}");
    fclose(fout);
}


// Initialize a test Section
void testSection_init(tTestSection* object, const char* code, const char* title) {
    assert(object != NULL);
    object->code = (char*)malloc((strlen(code) + 1) * sizeof(char));
    assert(object->code != NULL);
    strcpy(object->code, code);
    object->title = (char*)malloc((strlen(title) + 1) * sizeof(char));
    assert(object->title != NULL);
    strcpy(object->title, title);
    object->numTests = 0;
    object->tests = NULL;
    object->progress_file = NULL;
}

// Remove a test Section
void testSection_free(tTestSection* object) {
    int i;
    assert(object != NULL);
    assert(object->code != NULL);

    free(object->code);
    free(object->title);
    if (object->tests != NULL) {
        for (i = 0; i < object->numTests; i++) {
            test_free(&(object->tests[i]));
        }
        free(object->tests);
    }

}

// Add a test to the Section
void testSection_addTest(tTestSection* object, const char* code, const char* description, tTestResult result) {
    assert(object != NULL);
    object->numTests++;
    if (object->tests == NULL) {
        object->tests = (tTest*)malloc(object->numTests * sizeof(tTest));
    }
    else {
        object->tests = (tTest*)realloc(object->tests, object->numTests * sizeof(tTestSection));
    }
    assert(object->tests != NULL);
    test_init(&(object->tests[object->numTests - 1]), code, description, result);
}

// Update a test result
void testSection_updateTest(tTestSection* object, const char* test_code, tTestResult result) {
    tTest* test = NULL;

    assert(object != NULL);
    test = testSection_getTest(object, test_code);

    assert(test != NULL);
    test_updateTest(test, result);
}

// Get a pointer to a test
tTest* testSection_getTest(tTestSection* object, const char* test_code) {
    int i;
    assert(object != NULL);
    assert(test_code != NULL);
    for (i = 0; i < object->numTests; i++) {
        if (strcmp(object->tests[i].code, test_code) == 0) {
            return &(object->tests[i]);
        }
    }
    return NULL;
}

// Get test statistics
void testSection_getStats(tTestSection* object, int* total, int* passed, int* failed, int* not_implemented) {
    int i;
    assert(object != NULL);
    assert(total != NULL);
    assert(passed != NULL);
    assert(failed != NULL);
    assert(not_implemented != NULL);

    *total = object->numTests;
    *passed = 0;
    *failed = 0;
    *not_implemented = 0;
    for (i = 0; i < object->numTests; i++) {
        if (object->tests[i].result == TEST_PASSED) {
            (*passed)++;
        }
        else
            if (object->tests[i].result == TEST_FAILED) {
                (*failed)++;
            }
            else
                if (object->tests[i].result == TEST_FAILED) {
                    (*not_implemented)++;
                }
    }
}

// Print test section
void testSection_print(tTestSection* object, tBuffer* buffer) {
    int i;
    int total, passed, failed, not_implemented;

    assert(object != NULL);
    assert(buffer != NULL);

    testSection_getStats(object, &total, &passed, &failed, &not_implemented);

    bprintf(buffer, "\n\t=================================================================\n");
    bprintf(buffer, "\t%s\n", object->title);
    bprintf(buffer, "\t=================================================================\n");
    if (object->numTests == 0) {
        bprintf(buffer, "\tNO TEST DEFINED\n");
    }
    else {
        for (i = 0; i < object->numTests; i++) {
            test_print(&(object->tests[i]), buffer);
        }
    }
    bprintf(buffer, "\t=================================================================\n");
    if (total > 0) {
        bprintf(buffer, "\tTotal Tests: %d\n", total);
        bprintf(buffer, "\tPassed Tests: %d ( %2.2f %% )\n", passed, ((float)passed / (float)total) * 100.0);
        bprintf(buffer, "\tFailed Tests: %d ( %2.2f %%)\n", failed, ((float)failed / (float)total) * 100.0);
        //bprintf(buffer, "\tNot Implemented: %d ( %2.2f %%)\n", not_implemented, ((float)not_implemented/(float)total)*100.0);
        bprintf(buffer, "\t=================================================================\n");
    }
}

// Export a test section
void testSection_export(tTestSection* object, FILE* fout) {
    int i;
    int total, passed, failed, not_implemented;

    assert(object != NULL);
    assert(fout != NULL);

    testSection_getStats(object, &total, &passed, &failed, &not_implemented);

    fprintf(fout, "{ \"code\": \"%s\", \"title\": \"%s\", \"total\": %d, \"passed\": %d, \"failed\": %d, \"not_implemented\": %d, \"tests\": [", object->code, object->title, total, passed, failed, not_implemented);

    for (i = 0; i < object->numTests; i++) {
        if (i > 0) {
            fprintf(fout, ", ");
        }
        test_export(&(object->tests[i]), fout);
    }

    fprintf(fout, "]}");
}


// Initialize a test
void test_init(tTest* object, const char* code, const char* description, tTestResult result) {
    assert(object != NULL);
    object->code = (char*)malloc((strlen(code) + 1) * sizeof(char));
    assert(object->code != NULL);
    object->description = (char*)malloc((strlen(description) + 1) * sizeof(char));
    assert(object->description != NULL);
    strcpy(object->code, code);
    strcpy(object->description, description);
    object->result = TEST_RUNNING;
}

// Remove a test
void test_free(tTest* object) {
    assert(object != NULL);
    assert(object->code != NULL);
    assert(object->description != NULL);
    free(object->code);
    free(object->description);
}

// Update a test result
void test_updateTest(tTest* object, tTestResult result) {
    assert(object != NULL);
    object->result = result;
}

// Print test
void test_print(tTest* object, tBuffer* buffer) {
    assert(object != NULL);
    bprintf(buffer, "\t\t");
    if (object->result == TEST_RUNNING) {
        bprintf(buffer, "[%s]", "RUNNING");
    }
    else
        if (object->result == TEST_NOT_IMPLEMENTED) {
            bprintf(buffer, "[%s]", "NOT IMPLEMENTED");
        }
        else
            if (object->result == TEST_PASSED) {
                bprintf(buffer, "[%s]", "OK");
            }
            else
                if (object->result == TEST_FAILED) {
                    bprintf(buffer, "[%s]", "FAIL");
                }
    bprintf(buffer, ":\t [%s] %s\n", object->code, object->description);
}

// Export a test
void test_export(tTest* object, FILE* fout) {
    assert(object != NULL);
    assert(fout != NULL);

    fprintf(fout, "{ \"code\": \"%s\", \"description\": \"%s\", \"result\": ", object->code, object->description);
    if (object->result == TEST_RUNNING) {
        fprintf(fout, "\"%s\"}", "RUNNING");
    }
    else
        if (object->result == TEST_NOT_IMPLEMENTED) {
            fprintf(fout, "\"%s\"}", "NOT IMPLEMENTED");
        }
        else
            if (object->result == TEST_PASSED) {
                fprintf(fout, "\"%s\"}", "OK");
            }
            else
                if (object->result == TEST_FAILED) {
                    fprintf(fout, "\"%s\"}", "FAIL");
                }
}


// Start a test
void start_test(tTestSection* section, const char* code, const char* description) {

    assert(section != NULL);
    assert(code != NULL);
    assert(description != NULL);

    _save_progress(section, code, NULL);
    _print_progress(TEST_RUNNING, code, description);

    testSection_addTest(section, code, description, TEST_RUNNING);
}

// Finish a test
void end_test(tTestSection* section, const char* code, bool passed) {
    tTest* test = NULL;
    assert(section != NULL);
    assert(code != NULL);

    test = testSection_getTest(section, code);
    assert(test != NULL);

    if (passed) {
        _print_progress(TEST_PASSED, test->code, test->description);
        _save_progress(section, test->code, "OK");
        test_updateTest(test, TEST_PASSED);
    }
    else {
        _print_progress(TEST_FAILED, test->code, test->description);
        _save_progress(section, test->code, "FAIL");
        test_updateTest(test, TEST_FAILED);
    }
}

// Set output progress file
void _save_progress(tTestSection* section, const char* test_code, const char* test_result) {
    FILE* f_progress = NULL;
    if (section->progress_file == NULL) {
        return;
    }
    // Open the file
    f_progress = fopen(section->progress_file, "a");
    if (f_progress == NULL) {
        return;
    }

    if (test_result == NULL) {
        fprintf(f_progress, "TEST:START:{\"section_code\": \"%s\", \"test_code\": \"%s\"}\n", section->code, test_code);
    }
    else {
        fprintf(f_progress, "TEST:END:{\"section_code\": \"%s\", \"test_code\": \"%s\", \"result\": \"%s\"}\n", section->code, test_code, test_result);
    }

    // Close the file
    fclose(f_progress);
}

// Output test progress
void _print_progress(tTestResult result, const char* code, const char* description)
{
#if defined(PRINT_TEST_PROGRESS) || defined(DSLAB)
    tBuffer* buffer = NULL;

    // Reserve memory and open buffer
    buffer = (tBuffer*)malloc(sizeof(tBuffer));
    assert(buffer != NULL);
    open_buffer(buffer);

    switch (result) {
    case TEST_RUNNING: bprintf(buffer, "\n[START] ==> Running test [%s] - %s\n", code, description); break;
    case TEST_PASSED: bprintf(buffer, "\n[OK] ==> Finished test [%s] - %s\n", code, description); break;
    case TEST_FAILED: bprintf(buffer, "\n[FAIL] ==> Finished test [%s] - %s\n", code, description); break;
    case TEST_NOT_IMPLEMENTED: bprintf(buffer, "\n[FAIL] ==> Not implemented test [%s] - %s\n", code, description); break;
    }

#ifdef PRINT_TEST_PROGRESS
    printf("%s", buffer->data);
#endif
#ifdef DSLAB
    LSimLogger_log("INFO", buffer->data);
#endif

    // Close buffer and free memory
    close_buffer(buffer);
    free(buffer);
#endif
}

// Open and initializes a buffer
void open_buffer(tBuffer* buffer)
{
    assert(buffer != NULL);

    // Reserve memory for 1 char to store NULL at last position
    buffer->data = (char*)malloc(sizeof(char));
    assert(buffer->data != NULL);

    // Initialize values
    memset(buffer->data, 0, sizeof(char));
    buffer->count = 0;
}

// Close a buffer and free its internal string
void close_buffer(tBuffer* buffer) {
    free(buffer->data);
    buffer->data = NULL;
    buffer->count = 0;
}

// Clear a buffer, reset to empty string
void clear_buffer(tBuffer* buffer)
{
    // Reserve memory for 1 char to store NULL at last position
    buffer->data = (char*)realloc(buffer->data, sizeof(char));
    assert(buffer->data != NULL);

    // Initialize values
    memset(buffer->data, 0, sizeof(char));
    buffer->count = 0;
}

// Add a formated string to a buffer. Analog to functions like sprintf or fprintf
void bprintf(tBuffer* buffer, const char* pString, ...) {
    const int MAX_LENGTH = 2048;
    int size; //, length;
    va_list args;
    char tmp[MAX_LENGTH];

    // Read parameters
    va_start(args, pString);

    // Determine the size of new string using temporary string
    size = vsnprintf(tmp, MAX_LENGTH, pString, args);

    // Allocate memory for buffer. Add extra space for NULL termination
    buffer->count += size;
    buffer->data = (char*)realloc(buffer->data, (buffer->count + 1) * sizeof(char));

    // Update buffer
    strncat(buffer->data, tmp, size);

    // Close parameter's read
    va_end(args);
}

/************ fin test_suite.c *****************/

/*********** test.c *****************/
#include <assert.h>
#include <string.h>
#include "test_data.h"
#include "test.h"
#include "test_pr1.h"


// Write data to file
void save_data(const char* filename, const char* data) {
    FILE *fout;
    fout = fopen(filename, "w");
    assert(fout != NULL);
    fwrite(data, strlen(data), 1, fout);
    fclose(fout);
}


// Run all available tests
void testSuite_run(tTestSuite* test_suite, const char* input, const char* readme) {    
    const char* default_readme = "../README.txt";    
    const char* filename;
    
    assert(test_suite != NULL);
    
    // Load the README.txt file
    if (readme == NULL) {
        testSuite_load_learner(test_suite, default_readme);
    } else {
        testSuite_load_learner(test_suite, readme);
    }
    
    //////////////////////
    // Run tests for PR1
    //////////////////////
    
    // If no file is provided, use default data for PR1
    if (input == NULL) {
        filename = "test_data_pr1.csv";
        save_data(filename, test_data_pr1_str);        
    } else {
        filename = input;
    }
    // Run tests
    run_pr1(test_suite, filename);
}

/************ fin test.c *****************/

/*********** test_pr1.c *****************/
#include "test_pr1.h"
#include "api.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>

// Run all tests for PR1
bool run_pr1(tTestSuite *test_suite, const char *input) {
    bool ok = true;
    tTestSection* section = NULL;

    assert(test_suite != NULL);

    testSuite_addSection(test_suite, "PR1", "Tests for PR1 exercices");

    section = testSuite_getSection(test_suite, "PR1");
    assert(section != NULL);

    ok = run_pr1_ex1(section, input);
    ok = run_pr1_ex2(section, input) && ok;
    ok = run_pr1_ex3(section, input) && ok;
    ok = run_pr1_ex4(section, input) && ok;

    return ok;
}

// Run all tests for Exercice 1 of PR1
bool run_pr1_ex1(tTestSection *test_section, const char *input) {
	bool passed = true, failed = false;
	const char *version;

	/////////////////////////////
	/////  PR1 EX1 TEST 1  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX1_1", "Read version information.");
	// Get the version
	version = api_version();
	if (strcmp(version, "UOC PP 20242") != 0) {
		failed = true;
		passed = false;
	}
	end_test(test_section, "PR1_EX1_1", !failed);

	return passed;
}

// Run all tests for Exercice 2 of PR1
bool run_pr1_ex2(tTestSection *test_section, const char *input) {
	tApiError error;
	tTime duration;
	tDate release;
	tFilm film1, film2, film3, film4;
	tCatalog catalog;
	
	bool passed = true;
	bool failed = false;
	bool fail_all = false;
	
	// film1
	duration.hour = 2;
	duration.minutes = 49;
	release.day = 7;
	release.month = 11;
	release.year = 2014;
	film_init(&film1, "Interstellar", duration, 4, release, 4.8f, false);

	// film2
	duration.hour = 2;
	duration.minutes = 0;
	release.day = 15;
	release.month = 5;
	release.year = 2015;
	film_init(&film2, "Mad Max: Fury Road", duration, 0, release, 4.5f, false);

	// film3
	duration.hour = 3;
	duration.minutes = 9;
	release.day = 10;
	release.month = 12;
	release.year = 1999;
	film_init(&film3, "The Green Mile", duration, 2, release, 4.8f, true);

	// film4
	duration.hour = 1;
	duration.minutes = 57;
	release.day = 15;
	release.month = 12;
	release.year = 2006;
	film_init(&film4, "The Pursuit of Happyness", duration, 2, release, 4.4f, true);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 1  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_1", "Initialize the catalog data structure");
	// Initialize the catalog
	error = catalog_init(&catalog);
	if (error != E_SUCCESS) {
		failed = true;
		passed = false;
		fail_all = true;
	} else {
		if (catalog.filmList.first != NULL || catalog.filmList.last != NULL || catalog.filmList.count != 0 
		 || catalog.freeFilmList.first != NULL || catalog.freeFilmList.last != NULL || catalog.freeFilmList.count != 0) {
			failed = true;
			passed = false;
			fail_all = true;
		}
	}
	end_test(test_section, "PR1_EX2_1", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 2  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_2", "Add a film to an empty catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Add a film to an empty catalog
		error = catalog_add(&catalog, film1);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first != NULL || catalog.freeFilmList.last != NULL || catalog.freeFilmList.count != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next != NULL || strcmp(catalog.filmList.first->elem.name, film1.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_2", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 3  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_3", "Add a free film to a non-empty catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Add a free film to a non-empty catalog
		error = catalog_add(&catalog, film3);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 2) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first == NULL || catalog.freeFilmList.last == NULL || catalog.freeFilmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next == NULL || strcmp(catalog.filmList.first->elem.name, film1.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next->next != NULL || strcmp(catalog.filmList.first->next->elem.name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first->next != NULL || strcmp(catalog.freeFilmList.first->elem->name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (&(catalog.filmList.first->next->elem) != catalog.freeFilmList.first->elem) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_3", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 4  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_4", "Add a duplicated film to the catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Add a duplicated film to the catalog
		error = catalog_add(&catalog, film1);
		if (error != E_FILM_DUPLICATED) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 2) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first == NULL || catalog.freeFilmList.last == NULL || catalog.freeFilmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next == NULL || strcmp(catalog.filmList.first->elem.name, film1.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next->next != NULL || strcmp(catalog.filmList.first->next->elem.name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first->next != NULL || strcmp(catalog.freeFilmList.first->elem->name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (&(catalog.filmList.first->next->elem) != catalog.freeFilmList.first->elem) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_4", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 5  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_5", "Remove a non-existing film from the catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Remove a non-existing film from the catalog
		error = catalog_del(&catalog, film2.name);
		if (error != E_FILM_NOT_FOUND) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 2) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first == NULL || catalog.freeFilmList.last == NULL || catalog.freeFilmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next == NULL || strcmp(catalog.filmList.first->elem.name, film1.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next->next != NULL || strcmp(catalog.filmList.first->next->elem.name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first->next != NULL || strcmp(catalog.freeFilmList.first->elem->name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (&(catalog.filmList.first->next->elem) != catalog.freeFilmList.first->elem) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_5", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 6  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_6", "Remove a film from the catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Remove a film from the catalog
		error = catalog_del(&catalog, film1.name);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first == NULL || catalog.freeFilmList.last == NULL || catalog.freeFilmList.count != 1) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.filmList.first->next != NULL || strcmp(catalog.filmList.first->elem.name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first->next != NULL || strcmp(catalog.freeFilmList.first->elem->name, film3.name) != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (&(catalog.filmList.first->elem) != catalog.freeFilmList.first->elem) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_6", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 7  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_7", "Remove a free film from the catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Remove a free film from the catalog
		error = catalog_del(&catalog, film3.name);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			if (catalog.filmList.first != NULL || catalog.filmList.last != NULL || catalog.filmList.count != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			} else if (catalog.freeFilmList.first != NULL || catalog.freeFilmList.last != NULL || catalog.freeFilmList.count != 0) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX2_7", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 8  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_8", "Get the number of films");
	if (fail_all) {
		failed = true;
	} else {
		// Add films into the catalog
		catalog_add(&catalog, film1);
		catalog_add(&catalog, film2);
		catalog_add(&catalog, film3);
		catalog_add(&catalog, film4);
		
		if (catalog.filmList.first == NULL || catalog.filmList.last == NULL || catalog.filmList.count != 4) {
			failed = true;
			passed = false;
			fail_all = true;
		} else if (catalog.freeFilmList.first == NULL || catalog.freeFilmList.last == NULL || catalog.freeFilmList.count != 2) {
			failed = true;
			passed = false;
			fail_all = true;
		} else if (catalog_len(catalog) != 4 || catalog_freeLen(catalog) != 2) {
			failed = true;
			passed = false;
			fail_all = true;
		}
	}
	end_test(test_section, "PR1_EX2_8", !failed);
	
	/////////////////////////////
	/////  PR1 EX2 TEST 8  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_9", "Remove all films from the catalog");
	if (fail_all) {
		failed = true;
	} else {
		// Remove all the data from the catalog
		error = catalog_free(&catalog);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		} else if (catalog.filmList.first != NULL || catalog.filmList.last != NULL || catalog.filmList.count != 0) {
			failed = true;
			passed = false;
			fail_all = true;
		} else if (catalog.freeFilmList.first != NULL || catalog.freeFilmList.last != NULL || catalog.freeFilmList.count != 0) {
			failed = true;
			passed = false;
			fail_all = true;
		}
	}
	end_test(test_section, "PR1_EX2_9", !failed);
	
	// Release all data
	catalog_free(&catalog);
	film_free(&film1);
	film_free(&film2);
	film_free(&film3);
	film_free(&film4);
	
	return passed;
}

// Run all tests for Exercice 3 of PR1
bool run_pr1_ex3(tTestSection *test_section, const char *input) {
	tApiData data;
	tApiError error;
	tCSVEntry entry;
	int nPeople;
	int nSubscriptions;
	int nFilms;
	int nFreeFilms;

	bool passed = true;
	bool failed = false;
	bool fail_all = false;

	/////////////////////////////
	/////  PR1 EX3 TEST 1  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_1", "Initialize the API data structure");
	// Initialize the data
	error = api_initData(&data);
	if (error != E_SUCCESS) {
		failed = true;
		passed = false;
		fail_all = true;
	}
	end_test(test_section, "PR1_EX3_1", !failed);

	/////////////////////////////
	/////  PR1 EX3 TEST 2  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_2", "Add an invalid person");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "98765432J;Hendrik;Lorentz;987654321;hendrik.lorentz@example.com;his street, 5;00001;27/08/1954", "PERSONA");
		
		// Add an invalid person type
		error = api_addPerson(&data, entry);
		if (error != E_INVALID_ENTRY_TYPE) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "98765432J;Hendrik;Lorentz;987654321;hendrik.lorentz@example.com;his street, 5;00001;27/08/1954;oops", "PERSON");
		
		// Add an invalid person format
		error = api_addPerson(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "98765432J;Hendrik;Lorentz;987654321;hendrik.lorentz@example.com;his street, 5;27/08/1954", "PERSON");
		
		// Add an invalid person format
		error = api_addPerson(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_2", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 3  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_3", "Add a duplicated person");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "98765432J;Hendrik;Lorentz;987654321;hendrik.lorentz@example.com;his street, 5;00001;27/08/1954", "PERSON");
		
		// Add a valid person
		error = api_addPerson(&data, entry);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		if (!failed) {
			// Add a duplicated person
			error = api_addPerson(&data, entry);
			
			if (error != E_PERSON_DUPLICATED) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_3", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 4  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_4", "Add an invalid subscription");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "1;98765432J;01/01/2025;31/12/2025;Free;0;1", "SUBSCRIPTIO");
		
		// Add an invalid subscription type
		error = api_addSubscription(&data, entry);
		if (error != E_INVALID_ENTRY_TYPE) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "1;98765432J;01/01/2025;31/12/2025;Free;0;1;oops", "SUBSCRIPTION");
		
		// Add an invalid subscription format
		error = api_addSubscription(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "1;98765432J;01/01/2025;31/12/2025;Free;1", "SUBSCRIPTION");
		
		// Add an invalid subscription format
		error = api_addSubscription(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_4", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 5  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_5", "Add a duplicated subscription");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "1;98765432J;01/01/2025;31/12/2025;Free;0;1", "SUBSCRIPTION");
		
		// Add a valid subscription
		error = api_addSubscription(&data, entry);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		if (!failed) {
			// Add a duplicated subscription
			error = api_addSubscription(&data, entry);
			
			if (error != E_SUBSCRIPTION_DUPLICATED) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_5", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 6  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_6", "Add a subscription with non-existing person");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "2;00000000T;01/01/2025;31/12/2025;Free;0;1", "SUBSCRIPTION");
		
		// Add a valid subscription with non-exist person
		error = api_addSubscription(&data, entry);
		if (error != E_PERSON_NOT_FOUND) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_6", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 7  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_7", "Add an invalid film");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "Interstellar;02:49;4;07/11/2014;4.8;0", "FILMO");
		
		// Add an invalid film type
		error = api_addFilm(&data, entry);
		if (error != E_INVALID_ENTRY_TYPE) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "Interstellar;02:49;4;07/11/2014;4.8;0;oops", "FILM");
		
		// Add an invalid film format
		error = api_addFilm(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
		
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "Interstellar;4;07/11/2014;4.8;0", "FILM");
		
		// Add an invalid film format
		error = api_addFilm(&data, entry);
		if (error != E_INVALID_ENTRY_FORMAT) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_7", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 8  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_8", "Add a duplicated film");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_parseEntry(&entry, "Interstellar;02:49;4;07/11/2014;4.8;0", "FILM");
		
		// Add a valid film
		error = api_addFilm(&data, entry);
		if (error != E_SUCCESS) {
			failed = true;
			passed = false;
			fail_all = true;
		}
		
		if (!failed) {
			// Add a duplicated film
			error = api_addFilm(&data, entry);
			
			if (error != E_FILM_DUPLICATED) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
		
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX3_8", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 9  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_9", "Check the number of persons");
	if (fail_all) {
		failed = true;
	} else {
		nPeople = api_peopleCount(data);
		if (nPeople != 1) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			// Valid person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "33365111X;Marie;Curie;+33123456789;marie.curie@example.com;Radium street, 88;54321;07/10/1867", "PERSON");
			api_addPerson(&data, entry);
			csv_freeEntry(&entry);
			
			// Valid person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "55565432Z;Nils;Gustaf Dalen;555123123;nils.gustaf@example.com;Picadilly street, 123;12345;25/11/1972", "PERSON");
			api_addPerson(&data, entry);
			csv_freeEntry(&entry);
			
			// Duplicated person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "55565432Z;Nils;Gustaf Dalen;555123123;nils.gustaf@example.com;Picadilly street, 123;12345;25/11/1972", "PERSON");
			api_addPerson(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "Nils;Gustaf Dalen;555123123;nils.gustaf@example.com;Picadilly street, 123;12345;25/11/1972", "PERSON");
			api_addPerson(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "55565432Z;Nils;Gustaf Dalen;555123123;nils.gustaf@example.com;Picadilly street, 123;12345;25/11/1972", "PERSONA");
			api_addPerson(&data, entry);
			csv_freeEntry(&entry);
			
			nPeople = api_peopleCount(data);
			if (nPeople != 3) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX3_9", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 10  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_10", "Check the number of subscriptions");
	if (fail_all) {
		failed = true;
	} else {
		nSubscriptions = api_subscriptionsCount(data);
		if (nSubscriptions != 1) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			// Valid subscription
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "2;33365111X;01/05/2025;30/04/2026;Standard;29.95;3", "SUBSCRIPTION");
			api_addSubscription(&data, entry);
			csv_freeEntry(&entry);
			
			// Duplicated subscription
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "2;33365111X;01/05/2025;30/04/2026;Standard;29.95;3", "SUBSCRIPTION");
			api_addSubscription(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid subscription
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "3;33365111X;01/05/2025;30/04/2026;Standard;29.95;3", "SUBSCRIPTIONA");
			api_addSubscription(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid subscription
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "3;33365111X;01/05/2025;30/04/2026;Standard;29.95", "SUBSCRIPTION");
			api_addSubscription(&data, entry);
			csv_freeEntry(&entry);
			
			// Non-existing person
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "3;00000000T;01/05/2025;30/04/2026;Standard;29.95;3", "SUBSCRIPTION");
			api_addSubscription(&data, entry);
			csv_freeEntry(&entry);
			
			nSubscriptions = api_subscriptionsCount(data);
			if (nSubscriptions != 2) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX3_10", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 11 //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX3_11", "Check the number of films");
	if (fail_all) {
		failed = true;
	} else {
		nFilms = api_filmsCount(data);
		nFreeFilms = api_freeFilmsCount(data);
		if (nFilms != 1 || nFreeFilms != 0) {
			failed = true;
			passed = false;
			fail_all = true;
		} else {
			// Valid film
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "Blade Runner 2049;02:44;4;06/10/2017;4.6;1", "FILM");
			api_addFilm(&data, entry);
			csv_freeEntry(&entry);
			
			// Valid film
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "The Matrix;02:16;4;31/03/1999;4.9;1", "FILM");
			api_addFilm(&data, entry);
			csv_freeEntry(&entry);
			
			// Duplicated film
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "The Matrix;02:16;4;31/03/1999;4.9;1", "FILM");
			api_addFilm(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid film
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "Inception;02:28;0;16/07/2010;4.7;1;oops", "FILM");
			api_addFilm(&data, entry);
			csv_freeEntry(&entry);
			
			// Invalid film
			csv_initEntry(&entry);
			csv_parseEntry(&entry, "Inception;02:28;0;16/07/2010;4.7;1", "FILMO");
			api_addFilm(&data, entry);
			csv_freeEntry(&entry);
			
			nFilms = api_filmsCount(data);
			nFreeFilms = api_freeFilmsCount(data);
			if (nFilms != 3 || nFreeFilms != 2) {
				failed = true;
				passed = false;
				fail_all = true;
			}
		}
	}
	end_test(test_section, "PR1_EX3_11", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 12 //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_12", "Free API data");
	if (fail_all) {
		failed = true;
	} else {
		error = api_freeData(&data);
		nPeople = api_peopleCount(data);
		nSubscriptions = api_subscriptionsCount(data);
		nFilms = api_filmsCount(data);
		nFreeFilms = api_freeFilmsCount(data);
		if (error != E_SUCCESS || nPeople != 0 || nSubscriptions != 0 || nFilms != 0 || nFreeFilms != 0) {
			failed = true;
			passed = false;
			fail_all = true;
		}
	}
	end_test(test_section, "PR1_EX2_12", !failed);
	
	/////////////////////////////
	/////  PR1 EX3 TEST 13 //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX2_13", "Load data from file");
	if (fail_all) {
		failed = true;
	} else {
		error = api_loadData(&data, input, true);
		nPeople = api_peopleCount(data);
		nSubscriptions = api_subscriptionsCount(data);
		nFilms = api_filmsCount(data);
		nFreeFilms = api_freeFilmsCount(data);
		if (error != E_SUCCESS || nPeople != 5 || nSubscriptions != 5 || nFilms != 15 || nFreeFilms != 11) {
			failed = true;
			passed = false;
			fail_all = true;
		}
	}
	end_test(test_section, "PR1_EX2_13", !failed);
	
	// Release all data
	api_freeData(&data);

	return passed;
}

// Run all tests for Exercice 4 of PR1
bool run_pr1_ex4(tTestSection *test_section, const char *input) {
	tApiData data;
	tApiError error;
	tCSVEntry entry;
	tCSVEntry refEntry;
	tCSVData report;
	tCSVData refReport;
	int nPeople;
	int nSubscriptions;
	int nFilms;
	int nFreeFilms;
	bool passed = true;
	bool failed = false;
	bool fail_all = false;

	// Initialize the data
	error = api_initData(&data);
	if (error != E_SUCCESS) {
		passed = false;
		fail_all = true;
	}

	if (!fail_all) {
		error = api_loadData(&data, input, true);
		nPeople = api_peopleCount(data);
		nSubscriptions = api_subscriptionsCount(data);
		nFilms = api_filmsCount(data);
		nFreeFilms = api_freeFilmsCount(data);
		if (error != E_SUCCESS || nPeople != 5 || nSubscriptions != 5 || nFilms != 15 || nFreeFilms != 11) {
			passed = false;
			fail_all = true;
		}
	}

	/////////////////////////////
	/////  PR1 EX4 TEST 1  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_1", "Request a missing subscription");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		error = api_getSubscription(data, 999, &entry);
		if (error != E_SUBSCRIPTION_NOT_FOUND) {
			failed = true;
			passed = false;
		}
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX4_1", !failed);

	/////////////////////////////
	/////  PR1 EX4 TEST 2  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_2", "Request a valid subscription");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_initEntry(&refEntry);
		csv_parseEntry(&refEntry, "5;47051307Z;01/01/2023;31/12/2028;Premium;29.95;3", "SUBSCRIPTION");
		error = api_getSubscription(data, 5, &entry);
		if (error != E_SUCCESS || !csv_equalsEntry(entry, refEntry)) {
			failed = true;
			passed = false;
		}
		csv_freeEntry(&entry);
		csv_freeEntry(&refEntry);
	}
	end_test(test_section, "PR1_EX4_2", !failed);
 
	/////////////////////////////
	/////  PR1 EX4 TEST 3  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_3", "Request a missing film");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		error = api_getFilm(data, "Unknown", &entry);
		if (error != E_FILM_NOT_FOUND) {
			failed = true;
			passed = false;
		}
		csv_freeEntry(&entry);
	}
	end_test(test_section, "PR1_EX4_3", !failed);

	/////////////////////////////
	/////  PR1 EX4 TEST 4  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_4", "Request a valid film");
	if (fail_all) {
		failed = true;
	} else {
		csv_initEntry(&entry);
		csv_initEntry(&refEntry);
		csv_parseEntry(&refEntry, "The Pursuit of Happyness;01:57;2;15/12/2006;4.4;1", "FILM");
		error = api_getFilm(data, "The Pursuit of Happyness", &entry);
		if (error != E_SUCCESS || !csv_equalsEntry(entry, refEntry)) {
			failed = true;
			passed = false;
		}
		csv_freeEntry(&entry);
		csv_freeEntry(&refEntry);
	}
	end_test(test_section, "PR1_EX4_4", !failed);

	/////////////////////////////
	/////  PR1 EX4 TEST 5  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_5", "Get free films");
	if (fail_all) {
		failed = true;
	} else {
		csv_init(&report);
		csv_init(&refReport);

		csv_addStrEntry(&refReport, "Blade Runner 2049;02:44;4;06/10/2017;4.6;1", "FILM");	
		csv_addStrEntry(&refReport, "The Matrix;02:16;4;31/03/1999;4.9;1", "FILM");
		csv_addStrEntry(&refReport, "Inception;02:28;0;16/07/2010;4.7;1", "FILM");
		csv_addStrEntry(&refReport, "Die Hard;02:12;0;15/07/1988;4.3;1", "FILM");
		csv_addStrEntry(&refReport, "Superbad;01:53;1;17/08/2007;4.0;1", "FILM");
		csv_addStrEntry(&refReport, "Monty Python and the Holy Grail;01:31;1;03/04/1975;4.8;1", "FILM");
		csv_addStrEntry(&refReport, "The Green Mile;03:09;2;10/12/1999;4.8;1", "FILM");
		csv_addStrEntry(&refReport, "The Pursuit of Happyness;01:57;2;15/12/2006;4.4;1", "FILM");
		csv_addStrEntry(&refReport, "The Shining;02:26;3;23/05/1980;4.5;1", "FILM");
		csv_addStrEntry(&refReport, "A Nightmare on Elm Street;01:31;3;09/11/1984;4.1;1", "FILM");
		csv_addStrEntry(&refReport, "Get Out;01:44;3;24/02/2017;4.3;1", "FILM");

		error = api_getFreeFilms(data, &report);
		if (error != E_SUCCESS || !csv_equals(report, refReport)) {
			failed = true;
			passed = false;
		}
		csv_free(&report);
		csv_free(&refReport);
	}
	end_test(test_section, "PR1_EX4_5", !failed);

	/////////////////////////////
	/////  PR1 EX4 TEST 6  //////
	/////////////////////////////
	failed = false;
	start_test(test_section, "PR1_EX4_6", "Get films by genre");
	if (fail_all) {
		failed = true;
	} else {
		csv_init(&report);
		csv_init(&refReport);		

		csv_addStrEntry(&refReport, "Interstellar;02:49;4;07/11/2014;4.8;0" ,"FILM");
		csv_addStrEntry(&refReport, "Blade Runner 2049;02:44;4;06/10/2017;4.6;1" ,"FILM");
		csv_addStrEntry(&refReport, "The Matrix;02:16;4;31/03/1999;4.9;1" ,"FILM");

		error = api_getFilmsByGenre(data, &report, GENRE_SCIENCE_FICTION);
		if (error != E_SUCCESS || !csv_equals(report, refReport)) {
			failed = true;
			passed = false;
		}
		csv_free(&report);
		csv_free(&refReport);
		
		if (!failed) {
			csv_init(&report);
			csv_init(&refReport);		

			csv_addStrEntry(&refReport, "The Shining;02:26;3;23/05/1980;4.5;1" ,"FILM");
			csv_addStrEntry(&refReport, "A Nightmare on Elm Street;01:31;3;09/11/1984;4.1;1" ,"FILM");
			csv_addStrEntry(&refReport, "Get Out;01:44;3;24/02/2017;4.3;1" ,"FILM");

			error = api_getFilmsByGenre(data, &report, GENRE_HORROR);
			if (error != E_SUCCESS || !csv_equals(report, refReport)) {
				failed = true;
				passed = false;
			}
			csv_free(&report);
			csv_free(&refReport);
		}
	}
	end_test(test_section, "PR1_EX4_6", !failed);

	// Release all data
	api_freeData(&data);

	return passed;
}

/************ fin test_pr1.c *****************/

/*********** test_suite.c *****************/
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "test_suite.h"
#include <stdarg.h>

#ifdef DSLAB
#include "lsim.h"
#include "lsimLogger.h"
#endif

// Wait user key
void waitKey(tAppArguments parameters) {
    if (parameters.wait_on_exit) {
        printf("Press key to continue...");
        getchar();
    }
}

// Display help text
void help(const char* app_name) {
    printf("%s [--help] [--in <input_test_file>] [--out <output_file>] [--progress <progress_file>] [--readme <readme_file>]\n", app_name);
    printf("\t[%s] %s\n", "--help", "Show this help information.");
    printf("\t[%s] %s\n", "--no-wait", "Do not wait user key press on exit.");
    printf("\t[%s] %s\n", "--in", "Provide file with input test data in CSV format.");
    printf("\t[%s] %s\n", "--out", "Write the result of tests in a file in JSON format.");
    printf("\t[%s] %s\n", "--progress", "Write test progress in an output file.");
    printf("\t[%s] %s\n", "--readme", "Path to README.txt file.");
    printf("\t[%s] %s\n", "--hide-results", "Do not show tests results on the standard output.");
}

// Parse application arguments
bool parseArguments(tAppArguments* arguments, int argc, char** argv) {
    int i;

    // Initialize the arguments
    arguments->app_name = NULL;
    arguments->out_file = NULL;
    arguments->in_file = NULL;
    arguments->readme_file = NULL;
    arguments->progress_file = NULL;
    arguments->wait_on_exit = true;
    arguments->print_results_on_stdout = true;

    // Parse input arguments
    arguments->app_name = argv[0];
    for (i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--help") == 0) {
            help(argv[0]);
        }
        else if (strcmp(argv[i], "--no-wait") == 0) {
            arguments->wait_on_exit = false;
        }
        else if (strcmp(argv[i], "--in") == 0) {
            if (argc < i + 1) {
                help(argv[0]);
                return false;
            }
            arguments->in_file = argv[i + 1];
            i++;
        }
        else if (strcmp(argv[i], "--out") == 0) {
            if (argc < i + 1) {
                help(argv[0]);
                return false;
            }
            arguments->out_file = argv[i + 1];
            i++;
        }
        else if (strcmp(argv[i], "--progress") == 0) {
            if (argc < i + 1) {
                help(argv[0]);
                return false;
            }
            arguments->progress_file = argv[i + 1];
            i++;
        }
        else if (strcmp(argv[i], "--readme") == 0) {
            if (argc < i + 1) {
                help(argv[0]);
                return false;
            }
            arguments->readme_file = argv[i + 1];
            i++;
        }
        else if (strcmp(argv[i], "--hide-results") == 0) {
            arguments->print_results_on_stdout = false;
        }
    }

    return true;
}

// Initialize a test Suite
void testSuite_init(tTestSuite* object) {
    assert(object != NULL);
    object->learner.email = NULL;
    object->learner.username = NULL;
    object->learner.first_name = NULL;
    object->learner.last_name = NULL;
    object->learner.environment = NULL;
    object->learner.file_exists = false;
    object->numSections = 0;
    object->sections = NULL;
    object->progress_file = NULL;
}

// Set output progress file
void testSuite_set_progress_file(tTestSuite* object, char* progress_file) {
    object->progress_file = progress_file;
}

// Load learner data
bool testSuite_load_learner(tTestSuite* object, const char* file) {
    char buffer[BUFFER_SIZE];
    FILE* fin = NULL;
    int state;
    char* pos;

    assert(object != NULL);
    assert(file != NULL);

    fin = fopen(file, "r");
    if (fin == NULL) {
        object->learner.email = NULL;
        object->learner.username = NULL;
        object->learner.first_name = NULL;
        object->learner.last_name = NULL;
        object->learner.environment = NULL;
        object->learner.file_exists = false;
        return false;
    }

    state = 0;
    while (fgets(buffer, BUFFER_SIZE, fin)) {
        if (state == 0) {
            // Read email
            object->learner.email = (char*)malloc((strlen(buffer) + 1) * sizeof(char));
            memset(object->learner.email, 0, (strlen(buffer) + 1) * sizeof(char));
            strncpy(object->learner.email, buffer, strcspn(buffer, "\n\r"));
        }
        else if (state == 1) {
            // Read Surname, Name
            pos = strchr(buffer, ',');
            if (pos > 0) {
                // Copy the surnames
                object->learner.last_name = (char*)malloc((pos - buffer + 1) * sizeof(char));
                memset(object->learner.last_name, 0, (pos - buffer + 1) * sizeof(char));
                strncpy(object->learner.last_name, buffer, strcspn(buffer, ","));
                // Skip the comma
                pos++;
                // Skip initial blank spaces
                while (pos < &buffer[BUFFER_SIZE] && *pos == ' ') pos++;
                // Copy the first name
                object->learner.first_name = (char*)malloc((strlen(pos) + 1) * sizeof(char));
                memset(object->learner.first_name, 0, (strlen(pos) + 1) * sizeof(char));
                strncpy(object->learner.first_name, pos, strcspn(pos, "\n\r"));
            }
            else {
                object->learner.first_name = (char*)malloc((strlen(buffer) + 1) * sizeof(char));
                memset(object->learner.first_name, 0, (strlen(buffer) + 1) * sizeof(char));
                strncpy(object->learner.first_name, buffer, strlen(buffer));
            }
        }
        else if (state == 2) {
            object->learner.environment = (char*)malloc((strlen(buffer) + 1) * sizeof(char));
            strcpy(object->learner.environment, buffer);
        }
        else if (state > 2) {
            object->learner.environment = (char*)realloc(object->learner.environment, (strlen(object->learner.environment) + strlen(buffer) + 1) * sizeof(char));
            strcat(object->learner.environment, buffer);
        }
        state++;
    }

    object->learner.file_exists = true;

    fclose(fin);
    return true;
}

// Remove a test Suite
void testSuite_free(tTestSuite* object) {
    int i;
    assert(object != NULL);
    // Free learner data
    if (object->learner.email != NULL) {
        free(object->learner.email);
        object->learner.email = NULL;
    }
    if (object->learner.username != NULL) {
        free(object->learner.username);
        object->learner.username = NULL;
    }
    if (object->learner.first_name != NULL) {
        free(object->learner.first_name);
        object->learner.first_name = NULL;
    }
    if (object->learner.last_name != NULL) {
        free(object->learner.last_name);
        object->learner.last_name = NULL;
    }
    if (object->learner.environment != NULL) {
        free(object->learner.environment);
        object->learner.environment = NULL;
    }
    object->learner.file_exists = false;
    // Free test data
    if (object->sections != NULL) {
        for (i = 0; i < object->numSections; i++) {
            testSection_free(&(object->sections[i]));
        }
        free(object->sections);
    }
    object->progress_file = NULL;
}

// Add a test Section
void testSuite_addSection(tTestSuite* object, const char* code, const char* title) {
    assert(object != NULL);
    object->numSections++;
    if (object->sections == NULL) {
        object->sections = (tTestSection*)malloc(object->numSections * sizeof(tTestSection));
    }
    else {
        object->sections = (tTestSection*)realloc(object->sections, object->numSections * sizeof(tTestSection));
    }
    assert(object->sections != NULL);
    testSection_init(&(object->sections[object->numSections - 1]), code, title);
    if (object->progress_file != NULL) {
        object->sections[object->numSections - 1].progress_file = object->progress_file;
    }
}

// Add a test
void testSuite_addTest(tTestSuite* object, const char* section_code, const char* code, const char* description, tTestResult result) {
    tTestSection* section = NULL;
    assert(object != NULL);
    assert(section_code != NULL);
    assert(code != NULL);
    assert(description != NULL);

    section = testSuite_getSection(object, section_code);
    assert(section != NULL);

    testSection_addTest(section, code, description, result);
}

// Update a test result
void testSuite_updateTest(tTestSuite* object, const char* section_code, const char* test_code, tTestResult result) {
    tTestSection* section = NULL;

    assert(object != NULL);
    assert(section_code != NULL);
    assert(test_code != NULL);

    section = testSuite_getSection(object, section_code);
    assert(section != NULL);

    testSection_updateTest(section, test_code, result);
}

// Get a pointer to a section
tTestSection* testSuite_getSection(tTestSuite* object, const char* section_code) {
    int i;

    assert(object != NULL);
    assert(section_code != NULL);
    for (i = 0; i < object->numSections; i++) {
        if (strcmp(object->sections[i].code, section_code) == 0) {
            return &(object->sections[i]);
        }
    }
    return NULL;
}

// Get a pointer to a test
tTest* testSuite_getTest(tTestSuite* object, const char* section_code, const char* test_code) {
    tTestSection* section = NULL;

    assert(object != NULL);
    assert(section_code != NULL);
    assert(test_code != NULL);
    section = testSuite_getSection(object, section_code);
    assert(section != NULL);

    if (section != NULL) {
        return testSection_getTest(section, test_code);
    }

    return NULL;
}

// Get test statistics
void testSuite_getStats(tTestSuite* object, int* total, int* passed, int* failed, int* not_implemented) {
    int i;
    int s_total, s_passed, s_failed, s_not_implemented;
    assert(object != NULL);
    assert(total != NULL);
    assert(passed != NULL);
    assert(failed != NULL);
    assert(not_implemented != NULL);

    *total = 0;
    *passed = 0;
    *failed = 0;
    *not_implemented = 0;
    for (i = 0; i < object->numSections; i++) {
        testSection_getStats(&(object->sections[i]), &s_total, &s_passed, &s_failed, &s_not_implemented);
        *total += s_total;
        *passed += s_passed;
        *failed += s_failed;
        *not_implemented += s_not_implemented;
    }
}

// Print test suite
void testSuite_print(tTestSuite* object, tAppArguments parameters) {
    int i;
    int total, passed, failed, not_implemented;
    tBuffer* buffer = NULL;

    assert(object != NULL);

    // Reserve memory and open buffer
    buffer = (tBuffer*)malloc(sizeof(tBuffer));
    assert(buffer != NULL);
    open_buffer(buffer);

    // Print the header
    if (object->learner.file_exists) {
        bprintf(buffer, "\n=========================================================================\n");
        if (object->learner.first_name != NULL && object->learner.last_name != NULL) {
            bprintf(buffer, "\t Name: %s %s\n", object->learner.first_name, object->learner.last_name);
        }
        else {
            bprintf(buffer, "\t Name: <not provided>\n");
        }
        if (object->learner.email != NULL) {
            bprintf(buffer, "\t Email: %s\n", object->learner.email);
        }
        else {
            bprintf(buffer, "\t Email: <not provided>\n");
        }
        bprintf(buffer, "=========================================================================\n");
    }
    else {
        bprintf(buffer, "\n=========================================================================\n");
        bprintf(buffer, "\t NO LEARNER DATA\n");
        bprintf(buffer, "=========================================================================\n");
    }

    testSuite_getStats(object, &total, &passed, &failed, &not_implemented);

    bprintf(buffer, "\n=========================================================================\n");
    bprintf(buffer, "\t TEST RESULTS\n");
    bprintf(buffer, "=========================================================================\n");
    if (object->numSections == 0) {
        bprintf(buffer, "NO TEST DEFINED\n");
    }
    else {
        for (i = 0; i < object->numSections; i++) {
            testSection_print(&(object->sections[i]), buffer);
        }
    }
    bprintf(buffer, "\n=========================================================================\n");
    if (total > 0) {
        bprintf(buffer, "Total Tests: %d\n", total);
        bprintf(buffer, "Passed Tests: %d ( %2.02f %% )\n", passed, ((float)passed / (float)total) * 100.0);
        bprintf(buffer, "Failed Tests: %d ( %2.02f %% )\n", failed, ((float)failed / (float)total) * 100.0);
        //fprintf(buffer, "Not Implemented: %d ( %2.02f %% )\n", not_implemented, ((float)not_implemented/(float)total)*100.0);
        bprintf(buffer, "=========================================================================\n");
    }

    if (parameters.print_results_on_stdout)
        printf("%s", buffer->data);

#ifdef DSLAB
    float percent = 0.0;
    char summary[100];
    if (total > 0)
        percent = (float)passed / total * 100.0;
    sprintf(summary, "\tPassed %d of %d [%0.2f%%]\n", passed, total, percent);
    bool is_Ok = ((float)passed / (float)total) == 1.0;
    LSim_sendCorreccio(is_Ok, (char)percent, summary, buffer->data);
#endif

    // Close buffer and free memory
    close_buffer(buffer);
    free(buffer);
}

void write_nullable_field(FILE* fout, const char* value) {
    if (value == NULL) {
        fprintf(fout, "null");
    }
    else {
        fprintf(fout, "\"%s\"", value);
    }
}

// Export a test suite
void testSuite_export(tTestSuite* object, const char* output) {
    int i;
    int total, passed, failed, not_implemented;
    FILE* fout = NULL;

    assert(object != NULL);
    assert(output != NULL);

    fout = fopen(output, "w");
    assert(fout != NULL);

    fprintf(fout, "{ \"learner\": {\"first_name\": ");
    write_nullable_field(fout, object->learner.first_name);
    fprintf(fout, ", \"last_name\": ");
    write_nullable_field(fout, object->learner.last_name);
    fprintf(fout, ", \"email\": ");
    write_nullable_field(fout, object->learner.email);
    fprintf(fout, ", \"username\": ");
    write_nullable_field(fout, object->learner.username);
    fprintf(fout, ", \"environment\": ");
    write_nullable_field(fout, object->learner.environment);
    fprintf(fout, "}, ");

    testSuite_getStats(object, &total, &passed, &failed, &not_implemented);

    fprintf(fout, " \"total\": %d, \"passed\": %d, \"failed\": %d, \"not_implemented\": %d, \"sections\": [", total, passed, failed, not_implemented);

    for (i = 0; i < object->numSections; i++) {
        if (i > 0) {
            fprintf(fout, ", ");
        }
        testSection_export(&(object->sections[i]), fout);
    }

    fprintf(fout, "]}");
    fclose(fout);
}


// Initialize a test Section
void testSection_init(tTestSection* object, const char* code, const char* title) {
    assert(object != NULL);
    object->code = (char*)malloc((strlen(code) + 1) * sizeof(char));
    assert(object->code != NULL);
    strcpy(object->code, code);
    object->title = (char*)malloc((strlen(title) + 1) * sizeof(char));
    assert(object->title != NULL);
    strcpy(object->title, title);
    object->numTests = 0;
    object->tests = NULL;
    object->progress_file = NULL;
}

// Remove a test Section
void testSection_free(tTestSection* object) {
    int i;
    assert(object != NULL);
    assert(object->code != NULL);

    free(object->code);
    free(object->title);
    if (object->tests != NULL) {
        for (i = 0; i < object->numTests; i++) {
            test_free(&(object->tests[i]));
        }
        free(object->tests);
    }

}

// Add a test to the Section
void testSection_addTest(tTestSection* object, const char* code, const char* description, tTestResult result) {
    assert(object != NULL);
    object->numTests++;
    if (object->tests == NULL) {
        object->tests = (tTest*)malloc(object->numTests * sizeof(tTest));
    }
    else {
        object->tests = (tTest*)realloc(object->tests, object->numTests * sizeof(tTestSection));
    }
    assert(object->tests != NULL);
    test_init(&(object->tests[object->numTests - 1]), code, description, result);
}

// Update a test result
void testSection_updateTest(tTestSection* object, const char* test_code, tTestResult result) {
    tTest* test = NULL;

    assert(object != NULL);
    test = testSection_getTest(object, test_code);

    assert(test != NULL);
    test_updateTest(test, result);
}

// Get a pointer to a test
tTest* testSection_getTest(tTestSection* object, const char* test_code) {
    int i;
    assert(object != NULL);
    assert(test_code != NULL);
    for (i = 0; i < object->numTests; i++) {
        if (strcmp(object->tests[i].code, test_code) == 0) {
            return &(object->tests[i]);
        }
    }
    return NULL;
}

// Get test statistics
void testSection_getStats(tTestSection* object, int* total, int* passed, int* failed, int* not_implemented) {
    int i;
    assert(object != NULL);
    assert(total != NULL);
    assert(passed != NULL);
    assert(failed != NULL);
    assert(not_implemented != NULL);

    *total = object->numTests;
    *passed = 0;
    *failed = 0;
    *not_implemented = 0;
    for (i = 0; i < object->numTests; i++) {
        if (object->tests[i].result == TEST_PASSED) {
            (*passed)++;
        }
        else
            if (object->tests[i].result == TEST_FAILED) {
                (*failed)++;
            }
            else
                if (object->tests[i].result == TEST_FAILED) {
                    (*not_implemented)++;
                }
    }
}

// Print test section
void testSection_print(tTestSection* object, tBuffer* buffer) {
    int i;
    int total, passed, failed, not_implemented;

    assert(object != NULL);
    assert(buffer != NULL);

    testSection_getStats(object, &total, &passed, &failed, &not_implemented);

    bprintf(buffer, "\n\t=================================================================\n");
    bprintf(buffer, "\t%s\n", object->title);
    bprintf(buffer, "\t=================================================================\n");
    if (object->numTests == 0) {
        bprintf(buffer, "\tNO TEST DEFINED\n");
    }
    else {
        for (i = 0; i < object->numTests; i++) {
            test_print(&(object->tests[i]), buffer);
        }
    }
    bprintf(buffer, "\t=================================================================\n");
    if (total > 0) {
        bprintf(buffer, "\tTotal Tests: %d\n", total);
        bprintf(buffer, "\tPassed Tests: %d ( %2.2f %% )\n", passed, ((float)passed / (float)total) * 100.0);
        bprintf(buffer, "\tFailed Tests: %d ( %2.2f %%)\n", failed, ((float)failed / (float)total) * 100.0);
        //bprintf(buffer, "\tNot Implemented: %d ( %2.2f %%)\n", not_implemented, ((float)not_implemented/(float)total)*100.0);
        bprintf(buffer, "\t=================================================================\n");
    }
}

// Export a test section
void testSection_export(tTestSection* object, FILE* fout) {
    int i;
    int total, passed, failed, not_implemented;

    assert(object != NULL);
    assert(fout != NULL);

    testSection_getStats(object, &total, &passed, &failed, &not_implemented);

    fprintf(fout, "{ \"code\": \"%s\", \"title\": \"%s\", \"total\": %d, \"passed\": %d, \"failed\": %d, \"not_implemented\": %d, \"tests\": [", object->code, object->title, total, passed, failed, not_implemented);

    for (i = 0; i < object->numTests; i++) {
        if (i > 0) {
            fprintf(fout, ", ");
        }
        test_export(&(object->tests[i]), fout);
    }

    fprintf(fout, "]}");
}


// Initialize a test
void test_init(tTest* object, const char* code, const char* description, tTestResult result) {
    assert(object != NULL);
    object->code = (char*)malloc((strlen(code) + 1) * sizeof(char));
    assert(object->code != NULL);
    object->description = (char*)malloc((strlen(description) + 1) * sizeof(char));
    assert(object->description != NULL);
    strcpy(object->code, code);
    strcpy(object->description, description);
    object->result = TEST_RUNNING;
}

// Remove a test
void test_free(tTest* object) {
    assert(object != NULL);
    assert(object->code != NULL);
    assert(object->description != NULL);
    free(object->code);
    free(object->description);
}

// Update a test result
void test_updateTest(tTest* object, tTestResult result) {
    assert(object != NULL);
    object->result = result;
}

// Print test
void test_print(tTest* object, tBuffer* buffer) {
    assert(object != NULL);
    bprintf(buffer, "\t\t");
    if (object->result == TEST_RUNNING) {
        bprintf(buffer, "[%s]", "RUNNING");
    }
    else
        if (object->result == TEST_NOT_IMPLEMENTED) {
            bprintf(buffer, "[%s]", "NOT IMPLEMENTED");
        }
        else
            if (object->result == TEST_PASSED) {
                bprintf(buffer, "[%s]", "OK");
            }
            else
                if (object->result == TEST_FAILED) {
                    bprintf(buffer, "[%s]", "FAIL");
                }
    bprintf(buffer, ":\t [%s] %s\n", object->code, object->description);
}

// Export a test
void test_export(tTest* object, FILE* fout) {
    assert(object != NULL);
    assert(fout != NULL);

    fprintf(fout, "{ \"code\": \"%s\", \"description\": \"%s\", \"result\": ", object->code, object->description);
    if (object->result == TEST_RUNNING) {
        fprintf(fout, "\"%s\"}", "RUNNING");
    }
    else
        if (object->result == TEST_NOT_IMPLEMENTED) {
            fprintf(fout, "\"%s\"}", "NOT IMPLEMENTED");
        }
        else
            if (object->result == TEST_PASSED) {
                fprintf(fout, "\"%s\"}", "OK");
            }
            else
                if (object->result == TEST_FAILED) {
                    fprintf(fout, "\"%s\"}", "FAIL");
                }
}


// Start a test
void start_test(tTestSection* section, const char* code, const char* description) {

    assert(section != NULL);
    assert(code != NULL);
    assert(description != NULL);

    _save_progress(section, code, NULL);
    _print_progress(TEST_RUNNING, code, description);

    testSection_addTest(section, code, description, TEST_RUNNING);
}

// Finish a test
void end_test(tTestSection* section, const char* code, bool passed) {
    tTest* test = NULL;
    assert(section != NULL);
    assert(code != NULL);

    test = testSection_getTest(section, code);
    assert(test != NULL);

    if (passed) {
        _print_progress(TEST_PASSED, test->code, test->description);
        _save_progress(section, test->code, "OK");
        test_updateTest(test, TEST_PASSED);
    }
    else {
        _print_progress(TEST_FAILED, test->code, test->description);
        _save_progress(section, test->code, "FAIL");
        test_updateTest(test, TEST_FAILED);
    }
}

// Set output progress file
void _save_progress(tTestSection* section, const char* test_code, const char* test_result) {
    FILE* f_progress = NULL;
    if (section->progress_file == NULL) {
        return;
    }
    // Open the file
    f_progress = fopen(section->progress_file, "a");
    if (f_progress == NULL) {
        return;
    }

    if (test_result == NULL) {
        fprintf(f_progress, "TEST:START:{\"section_code\": \"%s\", \"test_code\": \"%s\"}\n", section->code, test_code);
    }
    else {
        fprintf(f_progress, "TEST:END:{\"section_code\": \"%s\", \"test_code\": \"%s\", \"result\": \"%s\"}\n", section->code, test_code, test_result);
    }

    // Close the file
    fclose(f_progress);
}

// Output test progress
void _print_progress(tTestResult result, const char* code, const char* description)
{
#if defined(PRINT_TEST_PROGRESS) || defined(DSLAB)
    tBuffer* buffer = NULL;

    // Reserve memory and open buffer
    buffer = (tBuffer*)malloc(sizeof(tBuffer));
    assert(buffer != NULL);
    open_buffer(buffer);

    switch (result) {
    case TEST_RUNNING: bprintf(buffer, "\n[START] ==> Running test [%s] - %s\n", code, description); break;
    case TEST_PASSED: bprintf(buffer, "\n[OK] ==> Finished test [%s] - %s\n", code, description); break;
    case TEST_FAILED: bprintf(buffer, "\n[FAIL] ==> Finished test [%s] - %s\n", code, description); break;
    case TEST_NOT_IMPLEMENTED: bprintf(buffer, "\n[FAIL] ==> Not implemented test [%s] - %s\n", code, description); break;
    }

#ifdef PRINT_TEST_PROGRESS
    printf("%s", buffer->data);
#endif
#ifdef DSLAB
    LSimLogger_log("INFO", buffer->data);
#endif

    // Close buffer and free memory
    close_buffer(buffer);
    free(buffer);
#endif
}

// Open and initializes a buffer
void open_buffer(tBuffer* buffer)
{
    assert(buffer != NULL);

    // Reserve memory for 1 char to store NULL at last position
    buffer->data = (char*)malloc(sizeof(char));
    assert(buffer->data != NULL);

    // Initialize values
    memset(buffer->data, 0, sizeof(char));
    buffer->count = 0;
}

// Close a buffer and free its internal string
void close_buffer(tBuffer* buffer) {
    free(buffer->data);
    buffer->data = NULL;
    buffer->count = 0;
}

// Clear a buffer, reset to empty string
void clear_buffer(tBuffer* buffer)
{
    // Reserve memory for 1 char to store NULL at last position
    buffer->data = (char*)realloc(buffer->data, sizeof(char));
    assert(buffer->data != NULL);

    // Initialize values
    memset(buffer->data, 0, sizeof(char));
    buffer->count = 0;
}

// Add a formated string to a buffer. Analog to functions like sprintf or fprintf
void bprintf(tBuffer* buffer, const char* pString, ...) {
    const int MAX_LENGTH = 2048;
    int size; //, length;
    va_list args;
    char tmp[MAX_LENGTH];

    // Read parameters
    va_start(args, pString);

    // Determine the size of new string using temporary string
    size = vsnprintf(tmp, MAX_LENGTH, pString, args);

    // Allocate memory for buffer. Add extra space for NULL termination
    buffer->count += size;
    buffer->data = (char*)realloc(buffer->data, (buffer->count + 1) * sizeof(char));

    // Update buffer
    strncat(buffer->data, tmp, size);

    // Close parameter's read
    va_end(args);
}

/************ fin test_suite.c *****************/

/*********** test.h *****************/
#ifndef __TEST__H
#define __TEST__H
#include "test_suite.h"

// Write data to file
void save_data(const char* filename, const char* data);

// Run all available tests
void testSuite_run(tTestSuite* test_suite, const char* input, const char* readme);

// Check if README.txt is available and have the correct information
//void readReadme(tTestSuite* test_suite);

#endif // __TEST__H
/************ fin test.h *****************/

/*********** test_data.h *****************/
#ifndef __TEST_DATA__H
#define __TEST_DATA__H

// Define test data for PR1
const char* test_data_pr1_str = "PERSON;98765432J;Hendrik;Lorentz;987654321;hendrik.lorentz@example.com;his street, 5;00001;27/08/1954\n" \
								"PERSON;33365111X;Marie;Curie;+33123456789;marie.curie@example.com;Radium street, 88;54321;07/10/1867\n" \
								"PERSON;55565432Z;Nils;Gustaf Dalen;555123123;nils.gustaf@example.com;Picadilly street, 123;12345;25/11/1972\n" \
								"PERSON;12345672C;Anne;Huiller;666789789;anne.huiller@example.com;rue percebe, 125;22222;12/01/1969\n" \
								"PERSON;47051307Z;James;Bond;707070707;bond.jamesbond@example.com;Downing street, 10;07077;12/01/1952\n" \
								"SUBSCRIPTION;1;98765432J;01/01/2025;31/12/2025;Free;0;1\n" \
								"SUBSCRIPTION;2;33365111X;01/05/2025;30/04/2026;Standard;29.95;3\n" \
								"SUBSCRIPTION;3;12345672C;15/06/2025;14/06/2026;Standard;29.95;3\n" \
								"SUBSCRIPTION;4;55565432Z;21/03/2025;20/03/2026;Free;0;1\n" \
								"SUBSCRIPTION;5;47051307Z;01/01/2023;31/12/2028;Premium;29.95;3\n" \
								"FILM;Interstellar;02:49;4;07/11/2014;4.8;0\n" \
								"FILM;Blade Runner 2049;02:44;4;06/10/2017;4.6;1\n" \
								"FILM;The Matrix;02:16;4;31/03/1999;4.9;1\n" \
								"FILM;Inception;02:28;0;16/07/2010;4.7;1\n" \
								"FILM;Mad Max: Fury Road;02:00;0;15/05/2015;4.5;0\n" \
								"FILM;Die Hard;02:12;0;15/07/1988;4.3;1\n" \
								"FILM;The Grand Budapest Hotel;01:39;1;28/02/2014;4.2;0\n" \
								"FILM;Superbad;01:53;1;17/08/2007;4.0;1\n" \
								"FILM;Monty Python and the Holy Grail;01:31;1;03/04/1975;4.8;1\n" \
								"FILM;Forrest Gump;02:22;2;06/07/1994;4.9;0\n" \
								"FILM;The Green Mile;03:09;2;10/12/1999;4.8;1\n" \
								"FILM;The Pursuit of Happyness;01:57;2;15/12/2006;4.4;1\n" \
								"FILM;The Shining;02:26;3;23/05/1980;4.5;1\n" \
								"FILM;A Nightmare on Elm Street;01:31;3;09/11/1984;4.1;1\n" \
								"FILM;Get Out;01:44;3;24/02/2017;4.3;1\n";
                                                  
#endif // TEST_DATA__H
/************ fin test_data.h *****************/

/*********** test_pr1.h *****************/
#ifndef __TEST_PR1_H__
#define __TEST_PR1_H__

#include <stdbool.h>
#include "test_suite.h"

// Run all tests for PR1
bool run_pr1(tTestSuite* test_suite, const char* input);

// Run tests for PR1 exercice 1
bool run_pr1_ex1(tTestSection* test_section, const char* input);

// Run tests for PR1 exercice 2
bool run_pr1_ex2(tTestSection* test_section, const char* input);

// Run tests for PR1 exercice 3
bool run_pr1_ex3(tTestSection* test_section, const char* input);

// Run tests for PR1 exercice 4
bool run_pr1_ex4(tTestSection* test_section, const char* input);


#endif // __TEST_PR1_H__
/************ fin test_pr1.h *****************/

/*********** test_suite.h *****************/
#ifndef __TEST_SUITE__H
#define __TEST_SUITE__H
#include <stdbool.h>
#include <stdbool.h>
#include <stdio.h>

// #define PRINT_TEST_PROGRESS
// #define DSLAB

// Size of the buffer used to read files data
#define BUFFER_SIZE 2048

// Arguments for a test program
typedef struct _AppArguments {
    char* app_name;
    char* out_file;
    char* in_file;
    char* readme_file;
    char* progress_file;
    bool wait_on_exit;
	bool print_results_on_stdout;
} tAppArguments;

// Status of a test
typedef enum {
    TEST_RUNNING,
    TEST_NOT_IMPLEMENTED,
    TEST_PASSED,
    TEST_FAILED
} tTestResult;

// A single test
typedef struct {
    // Code of the test
    char* code;
    // Description of the test
    char* description;
    // Result of the test
    tTestResult result;
} tTest;

// Grup of tests
typedef struct {
    // Code of the test section
    char* code;
    // Title of the section
    char* title;
    // Number of tests
    int numTests;
    // Array of tests
    tTest* tests;
    // Progress file
    char* progress_file;
} tTestSection;

// Test suit learner data
typedef struct {
    // Email
    char* email;
    // Username
    char* username;
    // First name
    char* first_name;
    // Last name
    char* last_name;
    // Environment
    char* environment;
    // Whether the learner data file exists or not
    bool file_exists;
} tLearnerData;

// Test suit with multiple sections
typedef struct {
    // Learner data
    tLearnerData learner;
    // Number of sections
    int numSections;
    // Array of sections
    tTestSection* sections;
    // Progress file
    char* progress_file;
} tTestSuite;

// Buffer. It is an autoincremental dynamic string
typedef struct {
    char* data;
    int count;
} tBuffer;

// Wait user key
void waitKey(tAppArguments parameters);

// Display help text
void help(const char* app_name);

// Parse application arguments
bool parseArguments(tAppArguments* arguments, int argc, char **argv);


// Initialize a test Suite
void testSuite_init(tTestSuite* object);

// Set output progress file
void testSuite_set_progress_file(tTestSuite* object, char* progress_file);

// Load learner data
bool testSuite_load_learner(tTestSuite* object, const char* file);

// Remove a test Suite
void testSuite_free(tTestSuite* object);

// Add a test Section
void testSuite_addSection(tTestSuite* object, const char* code, const char* title);

// Add a test
void testSuite_addTest(tTestSuite* object, const char* section_code, const char* code, const char* description, tTestResult result);

// Update a test result
void testSuite_updateTest(tTestSuite* object, const char* section_code, const char* test_code, tTestResult result);

// Get a pointer to a section
tTestSection* testSuite_getSection(tTestSuite* object, const char* section_code);

// Get a pointer to a test
tTest* testSuite_getTest(tTestSuite* object, const char* section_code, const char* test_code);

// Get test statistics
void testSuite_getStats(tTestSuite* object, int* total, int* passed, int* failed, int* not_implemented);

// Print test suite
void testSuite_print(tTestSuite* object, tAppArguments parameters);

// Export a test suite
void testSuite_export(tTestSuite* object, const char* output);



// Initialize a test Section
void testSection_init(tTestSection* object, const char* code, const char* title);

// Remove a test Section
void testSection_free(tTestSection* object);

// Add a test to the Section
void testSection_addTest(tTestSection* object, const char* code, const char* description, tTestResult result);

// Update a test result
void testSection_updateTest(tTestSection* object, const char* test_code, tTestResult result);

// Get a pointer to a test
tTest* testSection_getTest(tTestSection* object, const char* test_code);

// Get test statistics
void testSection_getStats(tTestSection* object, int* total, int* passed, int* failed, int* not_implemented);

// Print test section
void testSection_print(tTestSection* object, tBuffer* buffer);

// Export a test section
void testSection_export(tTestSection* object, FILE* fout);



// Initialize a test
void test_init(tTest* object, const char* code, const char* description, tTestResult result);

// Remove a test
void test_free(tTest* object);

// Update a test result
void test_updateTest(tTest* object, tTestResult result);

// Print test
void test_print(tTest* object, tBuffer* buffer);

// Export a test
void test_export(tTest* object, FILE* fout);


// Start a test
void start_test(tTestSection* section, const char* code, const char* description);

// Finish a test
void end_test(tTestSection* section, const char* code, bool passed);

// Set output progress file
void _save_progress(tTestSection* section, const char* test_code, const char* test_result);

// Output test progress
void _print_progress(tTestResult result, const char *code, const char *description);



// Open and initializes a buffer
void open_buffer(tBuffer* buffer);

// Close a buffer and free its internal string
void close_buffer(tBuffer* buffer);

// Clear a buffer, reset to empty string
void clear_buffer(tBuffer* buffer);

// Add a formated string to a buffer. Analog to functions like sprintf or fprintf
void bprintf(tBuffer* buffer, const char* pString, ...);

#endif // __TEST_SUITE__H

/************ fin test_suite.h *****************/

/*********** main.c *****************/
#include <stdio.h>
#include <stdlib.h>
#include "test_suite.h"
#include "test.h"

int main(int argc, char **argv)
{
	tAppArguments parameters;
    tTestSuite testSuite;
    
    // Parse input arguments
    if (!parseArguments(&parameters, argc, argv)) {
        printf("ERROR: Invalid input arguments");
        // Wait user to press a key to ensure error is shown
        waitKey(parameters);
        // Exit with error
        exit(EXIT_FAILURE);
    }
    
    // Initialize the test suite
    testSuite_init(&testSuite);
    
    // Set the progress file
    testSuite_set_progress_file(&testSuite, parameters.progress_file);
    
    // Run all tests
    testSuite_run(&testSuite, parameters.in_file, parameters.readme_file);
    
    // Print test results
    testSuite_print(&testSuite, parameters);
    
    // Store test results
    if (parameters.out_file != NULL) {
        testSuite_export(&testSuite, parameters.out_file);
        printf("Restults stored in %s\n", parameters.out_file);
    }
    if (parameters.progress_file != NULL) {        
        printf("Progress stored in %s\n", parameters.progress_file);
    }
    
    // Remove test suite data
    testSuite_free(&testSuite);    
    
    // Wait user to press a key to ensure results are shown
    waitKey(parameters);
    
	exit(EXIT_SUCCESS);
}

/************ fin main.c *****************/

/*********** Makefile *****************/
CC = gcc
CFLAGS = -Wall -g
LDFLAGS = -L./lib -lUOCPlay

SRC = src/main.c test/src/test_suite.c test/src/test_pr1.c test/src/test.c
INCLUDES = -I./test/include -I./UOCPlay/include

BIN_DIR = bin
TARGET = $(BIN_DIR)/UOC20242d

all: $(TARGET)

$(TARGET): $(SRC) lib/libUOCPlay.a
	mkdir -p $(BIN_DIR)
	$(CC) $(CFLAGS) $(INCLUDES) $(SRC) -o $(TARGET) $(LDFLAGS)

clean:
	rm -rf $(BIN_DIR) lib/*.a

/************ fin Makefile *****************/

